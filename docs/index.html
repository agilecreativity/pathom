<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="author" content="Wilker Lucio and Tony Kay">
<title>Pathom Developers Guide</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:initial}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px 0}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:.4em .75em 0 .75em;line-height:1;vertical-align:top}
.colist>table tr>td:first-of-type img{max-width:initial}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Pathom Developers Guide</h1>
<div class="details">
<span id="author" class="author">Wilker Lucio and Tony Kay</span><br>
<span id="revnumber">version 2,</span>
<span id="revdate">Aug 29, 2018</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a>
<ul class="sectlevel2">
<li><a href="#_aliases_used_in_code_examples">1.1. Aliases Used in Code Examples</a></li>
<li><a href="#_presentations">1.2. Presentations</a></li>
<li><a href="#_contributing">1.3. Contributing</a></li>
<li><a href="#_upgrade_notes">1.4. Upgrade notes</a>
<ul class="sectlevel3">
<li><a href="#_2_2_0_upgrade_guide">1.4.1. 2.2.0 - Upgrade guide</a></li>
<li><a href="#_2_2_0_beta11_2_2_0_rc1_breaking_changes">1.4.2. 2.2.0-beta11 &#8594; 2.2.0-RC1 - Breaking changes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_how_to_use_this_library">2. How to Use This Library</a></li>
<li><a href="#Connect">3. Pathom Connect</a>
<ul class="sectlevel2">
<li><a href="#_the_basics">3.1. The Basics</a></li>
<li><a href="#_baseline_boilerplate">3.2. Baseline Boilerplate</a></li>
<li><a href="#_resolvers">3.3. Resolvers</a>
<ul class="sectlevel3">
<li><a href="#_derived_computed_attributes">3.3.1. Derived/Computed Attributes</a></li>
<li><a href="#_single_inputs_establishing_context">3.3.2. Single Inputs&#8201;&#8212;&#8201;Establishing Context</a></li>
<li><a href="#GlobalResolvers">3.3.3. Resolver Without Input&#8201;&#8212;&#8201;Global Resolver</a></li>
<li><a href="#_resolvers_with_input">3.3.4. Resolvers with input</a></li>
<li><a href="#_multiple_inputs">3.3.5. Multiple inputs</a></li>
<li><a href="#_parameters">3.3.6. Parameters</a></li>
<li><a href="#_n_1_queries_and_batch_resolvers">3.3.7. N+1 Queries and Batch resolvers</a></li>
</ul>
</li>
<li><a href="#_connect_mutations">3.4. Connect mutations</a>
<ul class="sectlevel3">
<li><a href="#_mutations_setup">3.4.1. Mutations setup</a></li>
<li><a href="#_creating_mutations">3.4.2. Creating mutations</a></li>
<li><a href="#_async_mutations">3.4.3. Async mutations</a></li>
</ul>
</li>
<li><a href="#_shared_resolvers">3.5. Shared resolvers</a>
<ul class="sectlevel3">
<li><a href="#_resolver_data_format">3.5.1. Resolver data format</a></li>
<li><a href="#_mutation_data_format">3.5.2. Mutation data format</a></li>
<li><a href="#_using_code_register_code">3.5.3. Using <code>register</code></a></li>
<li><a href="#_plugins_with_resolvers">3.5.4. Plugins with resolvers</a></li>
</ul>
</li>
<li><a href="#_using_a_thread_pool_for_parallel_resolvers">3.6. Using a thread pool for parallel resolvers</a></li>
<li><a href="#_advanced_connect_details">3.7. Advanced Connect Details</a>
<ul class="sectlevel3">
<li><a href="#_connect_readers">3.7.1. Connect readers</a></li>
<li><a href="#_understanding_the_indexes">3.7.2. Understanding the indexes</a></li>
</ul>
</li>
<li><a href="#_exploration_with_pathom_viz_todo">3.8. Exploration with Pathom Viz #TODO</a></li>
</ul>
</li>
<li><a href="#_getting_started_on_pathom_core_engine">4. Getting Started on Pathom core engine</a>
<ul class="sectlevel2">
<li><a href="#_query_notation_introduction">4.1. Query Notation Introduction</a></li>
<li><a href="#_parsing_context">4.2. Parsing Context</a></li>
<li><a href="#_parsing_environment_and_the_reader">4.3. Parsing Environment and The Reader</a></li>
</ul>
</li>
<li><a href="#Core">5. Pathom Core Engine</a>
<ul class="sectlevel2">
<li><a href="#_parsers">5.1. Parsers</a>
<ul class="sectlevel3">
<li><a href="#_serial_parser">5.1.1. Serial parser</a></li>
<li><a href="#_async_parser">5.1.2. Async parser</a></li>
<li><a href="#Parallel-parser">5.1.3. Parallel parser</a></li>
</ul>
</li>
<li><a href="#Readers">5.2. Readers</a>
<ul class="sectlevel3">
<li><a href="#_functions_as_readers">5.2.1. Functions as Readers</a></li>
<li><a href="#map-dispatcher">5.2.2. Maps as Readers</a></li>
<li><a href="#vector-dispatcher">5.2.3. Vectors of Readers [aka composed readers]</a></li>
<li><a href="#_the_map_reader">5.2.4. The Map Reader</a></li>
</ul>
</li>
<li><a href="#Entities">5.3. Entities</a>
<ul class="sectlevel3">
<li><a href="#_using_code_p_entity_code">5.3.1. Using <code>p/entity</code></a></li>
<li><a href="#_understanding_joins">5.3.2. Understanding Joins</a></li>
<li><a href="#_dependent_attributes">5.3.3. Dependent Attributes</a></li>
<li><a href="#atom-entities">5.3.4. Atom entities</a></li>
<li><a href="#_union_queries">5.3.5. Union queries</a></li>
</ul>
</li>
<li><a href="#_error_handling">5.4. Error handling</a>
<ul class="sectlevel3">
<li><a href="#_debugging_exceptions">5.4.1. Debugging exceptions</a></li>
<li><a href="#_fail_fast">5.4.2. Fail fast</a></li>
<li><a href="#_raising_errors">5.4.3. Raising errors</a></li>
</ul>
</li>
<li><a href="#dispatch-helpers">5.5. Dispatch helpers</a></li>
<li><a href="#_mutations">5.6. Mutations</a></li>
<li><a href="#RequestCaching">5.7. Request Caching</a></li>
<li><a href="#_plugins">5.8. Plugins</a>
<ul class="sectlevel3">
<li><a href="#_the_environment_plugin">5.8.1. The Environment Plugin</a></li>
<li><a href="#_example_shard_switch">5.8.2. Example: Shard switch</a></li>
</ul>
</li>
<li><a href="#_testing_todo">5.9. Testing #TODO</a></li>
<li><a href="#_placeholders">5.10. Placeholders</a></li>
<li><a href="#_tracing">5.11. Tracing</a>
<ul class="sectlevel3">
<li><a href="#_logging_custom_events">5.11.1. Logging custom events</a></li>
</ul>
</li>
<li><a href="#_profiling_deprecated_prefer_the_tracing">5.12. Profiling [DEPRECATED, prefer the tracing]</a></li>
<li><a href="#_path_tracking">5.13. Path tracking</a></li>
<li><a href="#AsyncParsing">5.14. Async parsing</a>
<ul class="sectlevel3">
<li><a href="#_error_propagation">5.14.1. Error propagation</a></li>
<li><a href="#_js_promises">5.14.2. JS Promises</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#GraphQL">6. GraphQL Integration</a>
<ul class="sectlevel2">
<li><a href="#_simple_graphql">6.1. Simple GraphQL</a>
<ul class="sectlevel3">
<li><a href="#_simple_graphql_example">6.1.1. Simple GraphQL Example</a></li>
</ul>
</li>
<li><a href="#_graphql_and_connect">6.2. GraphQL and Connect</a>
<ul class="sectlevel3">
<li><a href="#_keywords_and_graphql_prefixes">6.2.1. Keywords and GraphQL – Prefixes</a></li>
<li><a href="#_graphql_entry_points_and_connect_ident_maps">6.2.2. GraphQL Entry Points and Connect Ident Maps</a></li>
<li><a href="#_setting_up_connect_with_graphql">6.2.3. Setting Up Connect with GraphQL</a></li>
<li><a href="#_loading_the_graphql_schema_and_creating_a_remote">6.2.4. Loading the GraphQL Schema and Creating a Remote</a></li>
<li><a href="#_adding_resolvers">6.2.5. Adding Resolvers</a></li>
<li><a href="#_queries">6.2.6. Queries</a></li>
<li><a href="#_fulcro_mutations_and_remote">6.2.7. Fulcro Mutations and Remote</a></li>
<li><a href="#ConnectMutations">6.2.8. Connect-Based Mutations</a></li>
<li><a href="#MultiInputIdents">6.2.9. Multiple Input Entry Points</a></li>
</ul>
</li>
<li><a href="#_complete_graphql_connect_example">6.3. Complete GraphQL Connect Example</a></li>
<li><a href="#edn_gql">6.4. EDN&#8594;GraphQL</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a><a class="link" href="#_introduction">1. Introduction</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>pathom</code> library provides a rich set of functionality to build robust parsers to
process graph queries for <a href="http://edn-query-language.org">EQL</a> queries.</p>
</div>
<div class="paragraph">
<p>The library includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A reader abstraction that allows for easy composition.</p>
</li>
<li>
<p>The concept of <code>entity</code> which works as a base framework for reusable sharable readers.</p>
</li>
<li>
<p>A plugin system with some built-in plugins:</p>
<div class="ulist">
<ul>
<li>
<p>Error handler: Handles errors at an attribute level.</p>
</li>
<li>
<p>Request cache: For caching the results of parsing repetition that can happen on a single request.</p>
</li>
<li>
<p>Profiler: a plugin to measure the time spent on each attribute during the parser.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>Connect</code>: a higher level abstraction that can resolve attribute relationships automatically. For
example automatic traversal of database joins or resolving data through network requests.
This enables exploratory capabilities and much simpler access when the need arises to do
extra work to resolve a single conceptual join.</p>
</li>
<li>
<p>GraphQL integration: Use GraphQL endpoints directly from your query system (in development).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most people will find the most leverage in the "Connect" features, which allow you to quickly build dynamic
query processing systems to easily satisfy client data requests.</p>
</div>
<div class="sect2">
<h3 id="_aliases_used_in_code_examples"><a class="anchor" href="#_aliases_used_in_code_examples"></a><a class="link" href="#_aliases_used_in_code_examples">1.1. Aliases Used in Code Examples</a></h3>
<div class="paragraph">
<p>Throughout the book our code examples will use aliases instead of explicit namespaces. The aliases used are as if we
had the following namespace requires:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">my-namespace</span>
  (<span class="symbol">:require</span>
    [com.wsscode.pathom.core <span class="symbol">:as</span> p]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
    [com.wsscode.pathom.connect.graphql <span class="symbol">:as</span> pcg]
    [com.wsscode.pathom.graphql <span class="symbol">:as</span> pg]
    [com.wsscode.pathom.trace <span class="symbol">:as</span> pt]
    [com.wsscode.pathom.profile <span class="symbol">:as</span> pp]
    [com.wsscode.common.async-clj(s) <span class="symbol">:refer</span> [let-chan &lt;!p go-catch &lt;? &lt;?maybe]]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>So, any time you see a usage of a namespace in a keyword or function like <code>p/parser</code> or <code>::p/reader</code> you should remember
that these are the namespaces involved.</p>
</div>
</div>
<div class="sect2">
<h3 id="_presentations"><a class="anchor" href="#_presentations"></a><a class="link" href="#_presentations">1.2. Presentations</a></h3>
<div class="paragraph">
<p>If you like to learn by seeing presentations, there are two that mention it:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://www.youtube.com/watch?v=yyVKf2U8YVg">Conj 2018 - Scaling Full Stack Applications</a>.</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=r3zywlNflJI">Dutch Clojure Days 2018 - Clojure Graph API&#8217;s</a>.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_contributing"><a class="anchor" href="#_contributing"></a><a class="link" href="#_contributing">1.3. Contributing</a></h3>
<div class="paragraph">
<p>This source for this book is at <a href="https://github.com/wilkerlucio/pathom/blob/master/docs/DevelopersGuide.adoc" class="bare">https://github.com/wilkerlucio/pathom/blob/master/docs/DevelopersGuide.adoc</a>.  Feel free to send a PR
with edits, corrections, or other contributions.  If you&#8217;re wanting to make a large edit, please open an issue first.</p>
</div>
</div>
<div class="sect2">
<h3 id="_upgrade_notes"><a class="anchor" href="#_upgrade_notes"></a><a class="link" href="#_upgrade_notes">1.4. Upgrade notes</a></h3>
<div class="paragraph">
<p>In pathom we try at most to don&#8217;t introduce breaking change, that means in some cases we prefer
to introduce a new function or namespace instead of replacing an old one when they might differ
in result. This part of the guide will provide information about suggestions to do when upgrading
to a certain version. Also in the exceptional cases we introduce breaking changes they will
also appear with upgrade notes here.</p>
</div>
<div class="sect3">
<h4 id="_2_2_0_upgrade_guide"><a class="anchor" href="#_2_2_0_upgrade_guide"></a><a class="link" href="#_2_2_0_upgrade_guide">1.4.1. 2.2.0 - Upgrade guide</a></h4>
<div class="sect4">
<h5 id="_supporting_resolver_libraries"><a class="anchor" href="#_supporting_resolver_libraries"></a><a class="link" href="#_supporting_resolver_libraries">Supporting resolver libraries</a></h5>
<div class="paragraph">
<p><strong>This is not a breaking change.</strong> Pathom <code>2.2.0</code> introduces new dispatchers to call resolvers and mutations, the old dispatchers
used to rely on a multi-method to invoke the calls, the new dispatchers will just look up
for a lamba in the resolver/mutation definition that&#8217;s stored in the index. The main advantage
is that we reduce the number of places we need to change when adding resolvers and mutations.
In the previous case you have 3 places to change, the index, the resolver dispatch and the
mutation dispatch, with the new dispatch there is just the index.</p>
</div>
<div class="paragraph">
<p>This will facilitate the creation of shared resolvers/mutations libraries that you can
inject and make part of your parsing system. To give an example shared library I have
wrote a demo repo implementing the <a href="https://github.com/wilkerlucio/pathom-connect-youtube">Youtube API for connect</a>.</p>
</div>
<div class="paragraph">
<p>To enable this feature you will have to change the dispatch function used in the parser
setup, replacing your resolvers fns with new ones provided by connect, example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">; this is the old setup</span>

<span class="comment">; setup indexes atom</span>
(<span class="keyword">def</span> <span class="function">indexes</span> (<span class="keyword">atom</span> {}))

<span class="comment">; setup resolver dispatch and factory</span>
(<span class="keyword">defmulti</span> <span class="function">resolver-fn</span> pc/resolver-dispatch)
(<span class="keyword">def</span> <span class="function">defresolver</span> (pc/resolver-factory resolver-fn indexes))

<span class="comment">; setup mutation dispatch and factory</span>
(<span class="keyword">defmulti</span> <span class="function">mutation-fn</span> pc/mutation-dispatch)
(<span class="keyword">def</span> <span class="function">defmutation</span> (pc/mutation-factory mutation-fn indexes))

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span>             [p/map-reader pc/all-readers]
                          <span class="symbol">::pc/resolver-dispatch</span> resolver-fn
                          <span class="symbol">::pc/mutate-dispatch</span>   mutation-fn
                          <span class="symbol">::pc/indexes</span>           @indexes
                          <span class="symbol">::db</span>                   (<span class="keyword">atom</span> {})}
             <span class="symbol">::p/mutate</span>  pc/mutate
             <span class="symbol">::p/plugins</span> [p/error-handler-plugin
                          p/request-cache-plugin
                          pp/profile-plugin]}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>To do the minimal change is to use this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">; minimal changes to support custom</span>

<span class="comment">; setup indexes atom</span>
(<span class="keyword">def</span> <span class="function">indexes</span> (<span class="keyword">atom</span> {}))

<span class="comment">; setup resolver dispatch and factory</span>
(<span class="keyword">defmulti</span> <span class="function">resolver-fn</span> pc/resolver-dispatch)
(<span class="keyword">def</span> <span class="function">defresolver</span> (pc/resolver-factory resolver-fn indexes))

<span class="comment">; setup mutation dispatch and factory</span>
(<span class="keyword">defmulti</span> <span class="function">mutation-fn</span> pc/mutation-dispatch)
(<span class="keyword">def</span> <span class="function">defmutation</span> (pc/mutation-factory mutation-fn indexes))

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span>             [p/map-reader pc/reader2 pc/ident-reader] <span class="comment">; use reader2</span>
                          <span class="comment">; replace resolver dispatch</span>
                          <span class="symbol">::pc/resolver-dispatch</span> pc/resolver-dispatch-embedded
                          <span class="comment">; replace mutation dispatch</span>
                          <span class="symbol">::pc/mutate-dispatch</span>   pc/mutation-dispatch-embedded
                          <span class="symbol">::pc/indexes</span>           @indexes
                          <span class="symbol">::db</span>                   (<span class="keyword">atom</span> {})}
             <span class="symbol">::p/mutate</span>  pc/mutate
             <span class="symbol">::p/plugins</span> [<span class="comment">; add connect plugin</span>
                          (pc/connect-plugin)
                          p/error-handler-plugin
                          p/request-cache-plugin
                          pp/profile-plugin]}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The new versions of <code>resolver-factory</code> and <code>mutation-factory</code> will add the lambdas into
the definition map, making those compatible with the new <code>*-dispatch-embedded</code>, so you get
your old resolvers plus any extra ones from libs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
From now on when I say <code>resolver</code> or <code>resolvers</code> I&#8217;m meaning both resolvers and mutations,
adding this note here so you don&#8217;t have to read all the repetition.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>From now on we will be recommending the new way of writing resolvers using the
<code>pc/defresolver</code> macro, I see a few advantages that I like to highlight about this approach:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Your resolvers become isolated building blocks on their own, instead of having to spread
it&#8217;s definition in the index + multi-method, now the map contais everything that resolver needs to be used</p>
</li>
<li>
<p>You get a fine control of what resolvers you want inject in a given parser, before wasn&#8217;t easy to
write several parsers using sub sets of resolvers, with each in a symbol you can compose as you please</p>
</li>
<li>
<p>Simplify the boilerplate, no more need to define the multi-methods for dispatching</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This is what the setup looks like by using the new map format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">; setup with map format</span>

<span class="comment">; this will generate a def for the symbol `some-resolver` and the def will</span>
<span class="comment">; contain a map that is the resolver definition, no external side effects</span>
(pc/defresolver some-resolver [env input]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">::id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">::name</span> <span class="symbol">::email</span>]}
  (<span class="keyword">get</span> (<span class="symbol">::db</span> env) (<span class="symbol">::id</span> input)))

<span class="comment">; define another resolver</span>
(pc/defresolver other-resolver <span class="keyword">..</span><span class="keyword">.</span>)

<span class="comment">; now it's a good practice to create a sequence containing the resolvers</span>
(<span class="keyword">def</span> <span class="function">app-registry</span> [some-resolver other-resolver])

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span>             [p/map-reader pc/reader2 pc/ident-reader]
                          <span class="symbol">::pc/resolver-dispatch</span> pc/resolver-dispatch-embedded
                          <span class="symbol">::pc/mutate-dispatch</span>   pc/mutation-dispatch-embedded
                          <span class="symbol">::db</span>                   (<span class="keyword">atom</span> {})}
             <span class="symbol">::p/mutate</span>  pc/mutate
             <span class="symbol">::p/plugins</span> [<span class="comment">; you can use the connect plugin to register your resolvers,</span>
                          <span class="comment">; but any plugin with the ::pc/register key will be also</span>
                          <span class="comment">; included in the index</span>
                          (pc/connect-plugin {<span class="symbol">::pc/register</span> app-registry})
                          p/error-handler-plugin
                          p/request-cache-plugin
                          pp/profile-plugin]}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pain point add is in the fact you now have to specify the resolvers to use,
but think that before this the only option was all or nothing. If you have resolvers
spread across many files, I suggest you create one list at the end of each namespace
containing all the resolvers from that file, this way you can combine those
in a later index. The resolver list will be flattened out when it&#8217;s processed, its
ok to send multiple lists inside lists, this facilitates de combination of lists of resolvers.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The multi-method format is still ok to use, there are no plans to remove it and keep using it
if you prefer.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_parallel_parser"><a class="anchor" href="#_parallel_parser"></a><a class="link" href="#_parallel_parser">Parallel parser</a></h5>
<div class="paragraph">
<p>Pathom <code>2.2.0</code> also introduces the parallel parser. Before this all the processing
of Pathom were done serially, one attribute at a time, the new parser brings the
ability to support the attributes to be processed in parallel, the mechanism is described
at the <a href="#Parallel-parser">parallel parser section</a>.</p>
</div>
<div class="paragraph">
<p>If you are using the <code>async-parser</code> the change to the parallel is just changing
the parser to <code>parallerl-parser</code> and the connect readers. If you are using the regular
sync parser, then you may need to adapt some things to support an async enviroment, here are
things to watch for:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If you wrote plugins, when wrapping things you must consider that their response will
be async (return core.async channels), One of the easiest ways to handle this is using the
<code>let-chan</code> macro, which is a let that automatically handles channels and make
the process transparent.</p>
</li>
<li>
<p>If you done recursive parser calls (that includes calls to functions like <code>join</code>, <code>entity</code> with arity 2)</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_tracer"><a class="anchor" href="#_tracer"></a><a class="link" href="#_tracer">Tracer</a></h5>
<div class="paragraph">
<p>Pathom <code>2.2.0</code> includes a new <a href="#_tracing">tracer feature</a>. I recommend you replace the old
profiler with this, you remove <code>pp/profile-plugin</code> and add the <code>p/tracer-plugin</code> (better as
the last plugin on your chain).</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_2_2_0_beta11_2_2_0_rc1_breaking_changes"><a class="anchor" href="#_2_2_0_beta11_2_2_0_rc1_breaking_changes"></a><a class="link" href="#_2_2_0_beta11_2_2_0_rc1_breaking_changes">1.4.2. 2.2.0-beta11 &#8594; 2.2.0-RC1 - Breaking changes</a></h4>
<div class="paragraph">
<p>In version <code>2.2.0-beta11</code> we introduced the <code>pc/connect-plugin</code> and <code>pc/register</code> with the intent
to provider an easier to write shared resolvers and also reduce the boilerplate to setup connect.</p>
</div>
<div class="paragraph">
<p>This strategy failed in be simple to setup a register and more integrations, because it relied
on multiple parts, a better strategy emerged by embedding the lamba to run the resolvers
and mutations in their own map instead, so they are complete and stand alone.</p>
</div>
<div class="paragraph">
<p>But to accomodate this the connect plugin and the <code>pc/register</code> had to change, before
the <code>pc/connect-plugin</code> was a var, now it&#8217;s an <code>fn</code> that you must call. The register used
to take the index atom, the multimethod for resolver and the multimethod for mutations, and
did a stateful mutation in all three. Now takes the index in a map format and returns another
index with the things registered, now it&#8217;s a pure function.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_use_this_library"><a class="anchor" href="#_how_to_use_this_library"></a><a class="link" href="#_how_to_use_this_library">2. How to Use This Library</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>We expect that most of our user base is made up of Om Next or Fulcro users.  The purpose of this library is to make it
much easier to build code that can process the graph query notation of these libraries on both the client and server side.
We expect you to have have one or more of the following needs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You want to fulfill a client UI query from some server-side data source(s).</p>
</li>
<li>
<p>You want to build a client-side parser for directly filling local UI data queries from a local data source.</p>
</li>
<li>
<p>You want to build a parser (client or server) that uses async APIs to fulfill different parts of a query. Perhaps
gluing together data sources from various micro-services.</p>
</li>
<li>
<p>You want to use a GraphQL API from the client.</p>
</li>
<li>
<p>You want to provide third-party users a GraphQL API (Future Work)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When building most parsers you&#8217;ll want to use <a href="#Connect">Pathom Connect</a>.</p>
</div>
<div class="paragraph">
<p>To process Fulcro/Om Next queries against GraphQL you&#8217;ll use the <a href="#GraphQL">GraphQL Integration</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Connect"><a class="anchor" href="#Connect"></a><a class="link" href="#Connect">3. Pathom Connect</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>Connect</code> provides is a high-level abstraction layer for building query processing code. It handles a number of the gory
details in an automatic way that allows you to focus more on your data model and less on the parser itself.  It generates
an an index of your graph&#8217;s features that can be used for a number of very useful features:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Auto-complete of graph queries in tools for data exploration (see <a href="https://github.com/wilkerlucio/oge">OgE</a>).</p>
</li>
<li>
<p>Graph edge generation from the index&#8217;s connection information.</p>
</li>
<li>
<p>Multiple ways to reach a given attribute, automatically resolved via known reachable edges and transitive relations.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>Connect</code> index is a rich source of information about how your attributes connect and how they
can locate each other.</p>
</div>
<div class="sect2">
<h3 id="_the_basics"><a class="anchor" href="#_the_basics"></a><a class="link" href="#_the_basics">3.1. The Basics</a></h3>
<div class="paragraph">
<p>In order to use connect you need to understand some basics about Pathom&#8217;s core features.  These are covered in detail in
<a href="#Core">later chapters</a>, but you&#8217;ll easily understand the basics we need for connect without going into great detail.</p>
</div>
<div class="paragraph">
<p>You&#8217;re going to be defining a <strong>parser</strong> that uses an <strong>environment</strong> and <strong>graph query</strong> to produce a <strong>tree of data</strong> from
arbitrary data sources.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re unfamiliar with the Om Next/Fulcro graph query notation, you should first read up on that in the
<a href="http://book.fulcrologic.com/#_the_query_and_mutation_language">Fulcro Developer&#8217;s Guide</a>.</p>
</div>
<div class="paragraph">
<p>Some simple examples of what we&#8217;re doing are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; query</span>
[<span class="symbol">:person/name</span>]

<span class="comment">;; possible result</span>
{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Samantha</span><span class="delimiter">&quot;</span></span>}

<span class="comment">;; query</span>
[<span class="symbol">:account/id</span>
 {<span class="symbol">:billing/charges</span> [<span class="symbol">:charge/amount</span>]}]

<span class="comment">;; possible result</span>
{<span class="symbol">:account/id</span> <span class="integer">1</span>
 <span class="symbol">:billing/charges</span> [{<span class="symbol">:charge/amount</span> <span class="integer">11</span>}
                   {<span class="symbol">:charge/amount</span> <span class="integer">22</span>}]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make sure we&#8217;re on the same page, here&#8217;s a quick bit of vocabulary:</p>
</div>
<div class="dlist Horizontal">
<dl>
<dt>Environment</dt>
<dd>
<p>A map of configuration and context that is used to configure the parser and is also passed to the reader.</p>
</dd>
<dt>Resolver</dt>
<dd>
<p>A Pathom Connect component that you write to indicate ways in which data attributes can be resolved against your data sources.  Resolvers are composed together into a connect-based <strong>Reader</strong>.</p>
</dd>
<dt>Reader</dt>
<dd>
<p>A component of that attempts to resolve elements of the query (one
at a time).  When using connect you also use a built-in <strong>Map Reader</strong> that can pull attributes that are already in the environment without having to do further work against your underlying resolvers and data sources.</p>
</dd>
<dt>Connect Indexes</dt>
<dd>
<p>A set of indexes that are filled with resolver data and allow connect to understand how graph queries can be resolved by the resolvers.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_baseline_boilerplate"><a class="anchor" href="#_baseline_boilerplate"></a><a class="link" href="#_baseline_boilerplate">3.2. Baseline Boilerplate</a></h3>
<div class="paragraph">
<p>Connect is generally set up with the minimal steps every time.  Other sections of this book cover the options in
more detail, but for the moment take this small bit of code as the general "starting point" for writing a connect-based
query processing system:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.connect.getting-started</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

<span class="comment">;; Define one or more resolvers</span>
(pc/defresolver some-symbol [env input] <span class="keyword">..</span><span class="keyword">.</span>)
(pc/defresolver some-other-symbol [env input] <span class="keyword">..</span><span class="keyword">.</span>)
<span class="keyword">..</span><span class="keyword">.</span>

<span class="comment">;; resolvers are just maps, we can compose many using sequences</span>
(<span class="keyword">def</span> <span class="function">my-app-registry</span> [some-symbol some-other-symbol])

<span class="comment">;; Create a parser that uses the resolvers:</span>
(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parallel-parser
    {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span>               [p/map-reader
                                            pc/parallel-reader
                                            pc/open-ident-reader
                                            p/env-placeholder-reader]
                  <span class="symbol">::p/placeholder-prefixes</span> #{<span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;</span><span class="delimiter">&quot;</span></span>}}
     <span class="symbol">::p/mutate</span>  pc/mutate-async
     <span class="symbol">::p/plugins</span> [(pc/connect-plugin {<span class="symbol">::pc/register</span> my-app-registry}) <span class="comment">; setup connect and use our resolvers</span>
                  p/error-handler-plugin
                  p/request-cache-plugin
                  p/trace-plugin]}))

<span class="comment">; note the parallel parser call will return a channel, you must read the value on it</span>
<span class="comment">; to get the parser results</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_resolvers"><a class="anchor" href="#_resolvers"></a><a class="link" href="#_resolvers">3.3. Resolvers</a></h3>
<div class="paragraph">
<p>In <code>Connect</code> you implement the graph by creating <code>resolvers</code>, those resolvers are functions that expose some data on the graph.</p>
</div>
<div class="paragraph">
<p>A resolver has a few basic elements:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Inputs – A set of attributes that must be in the current parsing context for the resolver to be able to work.  Inputs is
optional, and missing inputs means that the resolver is always capable of working independent of the current parsing context.</p>
</li>
<li>
<p>Outputs - A query-like notation that gives the "pattern" of the part of the query the resolver is able to resolve. This is typically a list of attributes/joins, where joins typically include a simple subquery.</p>
</li>
<li>
<p>A lambda - A <code>(fn [env input-data] tree-of-promised-output)</code> that takes the inputs and turns them into a tree that satisfies the "output query".</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>So you might define a resolver like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(pc/defresolver person-resolver [{<span class="symbol">:keys</span> [database] <span class="symbol">:as</span> env} {<span class="symbol">:keys</span> [person/id]}]
  {<span class="symbol">::pc/input</span> #{<span class="symbol">:person/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:person/first-name</span> <span class="symbol">:person/age</span>]}
  (<span class="keyword">let</span> [person (my-database/get-person database id)]
    {<span class="symbol">:person/age</span>        (<span class="symbol">:age</span> person)
     <span class="symbol">:person/first-name</span> (<span class="symbol">:first-name</span> person)}))</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
If you use Cursive, you can ask it to resolve the <code>pc/defresolver</code> as a <code>defn</code> and you will get proper symbol resolution
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Where the <code>database</code> in the environment would be supplied when running the parser, and the input would have to be
found in the current context.  Remember that graph queries are contextual&#8230;&#8203;you have to have a starting node to work
from, so in the above example we&#8217;re assuming that during our parse we&#8217;ll reach a point where the context contains
a <code>:person/id</code>.  The <code>my-database</code> stuff is just made up for this example, and is intended to show you that your
data source need not remotely match the schema of your graph query.</p>
</div>
<div class="paragraph">
<p>Pathom will scan through the defined resolvers in order to try to satisfy all of the properties in a query.  So, technically
you can split up your queries as much as makes sense into separate resolvers, and as long as the inputs are in the context
Pathom will assemble things back together.</p>
</div>
<div class="paragraph">
<p>Of course, it doesn&#8217;t make sense in this case to do so, because each resolver would end up running a new query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(pc/defresolver person-age-resolver [{<span class="symbol">:keys</span> [database] <span class="symbol">:as</span> env} {<span class="symbol">:keys</span> [person/id]}]
  {<span class="symbol">::pc/input</span> #{<span class="symbol">:person/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:person/age</span>]}
  (<span class="keyword">let</span> [person (my-database/get-person database id)]
    {<span class="symbol">:person/age</span> (<span class="symbol">:age</span> person)}))

(pc/defresolver person-first-name-resolver [{<span class="symbol">:keys</span> [database] <span class="symbol">:as</span> env} {<span class="symbol">:keys</span> [person/id]}]
  {<span class="symbol">::pc/input</span> #{<span class="symbol">:person/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:person/first-name</span>]}
  (<span class="keyword">let</span> [person (my-database/get-person database id)]
    {<span class="symbol">:person/first-name</span> (<span class="symbol">:first-name</span> person)}))

<span class="keyword">..</span><span class="keyword">.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The point is that a single-level query like <code>[:person/id :person/first-name :person/age]</code> can be satisfied and "folded together"
by pathom over any number of resolvers.</p>
</div>
<div class="paragraph">
<p>This fact is the basis of parser (de)composition and extensibility.  It can also come in handy for performance
refinements when there are computed attributes.</p>
</div>
<div class="sect3">
<h4 id="_derived_computed_attributes"><a class="anchor" href="#_derived_computed_attributes"></a><a class="link" href="#_derived_computed_attributes">3.3.1. Derived/Computed Attributes</a></h4>
<div class="paragraph">
<p>There are times when you&#8217;d like to provide an attribute that is computed in some fashion.  You can, of course, simply
compute it within the resolver along with other properties like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(pc/defresolver person-resolver [{<span class="symbol">:keys</span> [database] <span class="symbol">:as</span> env} {<span class="symbol">:keys</span> [person/id]}]
  {<span class="symbol">::pc/input</span> #{<span class="symbol">:person/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:person/first-name</span> <span class="symbol">:person/last-name</span> <span class="symbol">:person/full-name</span> <span class="symbol">:person/age</span>]}
  (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [age first-name last-name]} (my-database/get-person database id)]
    {<span class="symbol">:person/age</span>        age
     <span class="symbol">:person/first-name</span> first-name
     <span class="symbol">:person/last-name</span>  last-name
     <span class="symbol">:person/full-name</span>  (<span class="keyword">str</span> first-name <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span> last-name) <span class="comment">; COMPUTED</span>
     <span class="keyword">..</span><span class="keyword">.</span>}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>but this means that you&#8217;ll take the overhead of the computation when <strong>any</strong> query relate to person comes up.  You can
instead spread such attributes out into other resolvers as we discussed previously, which will only be invoked if the
query actually asks for those properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(pc/defresolver person-resolver [{<span class="symbol">:keys</span> [database] <span class="symbol">:as</span> env} {<span class="symbol">:keys</span> [person/id]}]
  {<span class="symbol">::pc/input</span> #{<span class="symbol">:person/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:person/first-name</span> <span class="symbol">:person/last-name</span> <span class="symbol">:person/age</span>]}
  (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [age first-name last-name]} (my-database/get-person database id)]
    {<span class="symbol">:person/age</span>        age
     <span class="symbol">:person/first-name</span> first-name
     <span class="symbol">:person/last-name</span>  last-name}))

(pc/defresolver person-name-resolver [_ {<span class="symbol">:person/keys</span> [first-name last-name]}]
  {<span class="symbol">::pc/input</span> #{<span class="symbol">:person/first-name</span> <span class="symbol">:person/last-name</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:person/full-name</span>]}
  {<span class="symbol">:person/full-name</span> (<span class="keyword">str</span> first-name <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span> last-name)})</code></pre>
</div>
</div>
<div class="paragraph">
<p>This combination of resolvers can still resolve all of the properties in <code>[:person/full-name :person/age]</code> (if
<code>:person/id</code> is in the context), but a query for just <code>[:person/age]</code> won&#8217;t invoke any of the logic for the
<code>person-name-resolver</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_single_inputs_establishing_context"><a class="anchor" href="#_single_inputs_establishing_context"></a><a class="link" href="#_single_inputs_establishing_context">3.3.2. Single Inputs&#8201;&#8212;&#8201;Establishing Context</a></h4>
<div class="paragraph">
<p>So far we have seen how to define a resolver that can work <strong>as long as</strong> the inputs are already in the environment.  You&#8217;re
almost certainly wondering how to do that.</p>
</div>
<div class="paragraph">
<p>One way is to define <a href="#GlobalResolvers">global resolvers</a> and start the query from them, but very often you&#8217;d just
like to be able to say "I&#8217;d like the first name of person with id 42."</p>
</div>
<div class="paragraph">
<p>Om Next/Fulcro use "idents" to specify exactly that sort of query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{[<span class="symbol">:person/id</span> <span class="integer">42</span>] [<span class="symbol">:person/first-name</span>]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above is a join on an ident, and the expected result is a map with the ident as a key:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{[<span class="symbol">:person/id</span> <span class="integer">42</span>] {<span class="symbol">:person/first-name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The query <strong>itself</strong> has everything you need to establish the <strong>context</strong> for running the <code>person-resolver</code>,
and in fact that is how Pathom single-input resolvers work.</p>
</div>
<div class="paragraph">
<p>If you use an ident in a query then Pathom is smart enough to know that it can use that ident to establish the context
for finding resolvers.  In other words, in the query above the ident <code>[:person/id 42]</code> is turned
into the <strong>parsing context</strong> <code>{:person/id 42}</code>, which satisfies the <strong>input</strong> of any resolver that needs
<code>:person/id</code> to run.</p>
</div>
</div>
<div class="sect3">
<h4 id="GlobalResolvers"><a class="anchor" href="#GlobalResolvers"></a><a class="link" href="#GlobalResolvers">3.3.3. Resolver Without Input&#8201;&#8212;&#8201;Global Resolver</a></h4>
<div class="paragraph">
<p>A resolver that requires no input can output its results at any point in the graph, thus it is really a global resolver.
Pay particular note to the qualfication: <strong>any point in the graph</strong>.  Not just root.  Thus, a resolver without inputs
can "inject" its outputs into any level of the query graph result.</p>
</div>
<div class="paragraph">
<p>We&#8217;re going to start building a parser that can satisfy queries about a music store. So, we&#8217;ll start with a global resolver
that can resolve the "latest product".  The code below shows the entire code needed, boilerplate and all:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.connect.getting-started</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
            [com.wsscode.pathom.profile <span class="symbol">:as</span> pp]))

<span class="comment">; creating our first resolver</span>
(pc/defresolver latest-product [_ _]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">::latest-product</span> [<span class="symbol">:product/id</span> <span class="symbol">:product/title</span> <span class="symbol">:product/price</span>]}]}
  {<span class="symbol">::latest-product</span> {<span class="symbol">:product/id</span>    <span class="integer">1</span>
                     <span class="symbol">:product/title</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Acoustic Guitar</span><span class="delimiter">&quot;</span></span>
                     <span class="symbol">:product/price</span> <span class="float">199.99</span>M}})

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parallel-parser
    {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span>               [p/map-reader
                                            pc/parallel-reader
                                            pc/open-ident-reader
                                            p/env-placeholder-reader]
                  <span class="symbol">::p/placeholder-prefixes</span> #{<span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;</span><span class="delimiter">&quot;</span></span>}}
     <span class="symbol">::p/mutate</span>  pc/mutate-async
     <span class="symbol">::p/plugins</span> [(pc/connect-plugin {<span class="symbol">::pc/register</span> latest-product})
                  p/error-handler-plugin
                  p/request-cache-plugin
                  p/trace-plugin]}))

(<span class="keyword">comment</span>
  (parser {} [<span class="symbol">::latest-product</span>]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our first resolver exposes the attribute <code>::latest-product</code>, and since it doesn&#8217;t require any input it is a global resolver.
Also, note that our output description includes the full output details (including nested attributes), this is mostly
useful for auto-complete on UI&#8217;s and automatic testing. If you return extra data it will still end up in the output
context.</p>
</div>
<div class="paragraph">
<p>Try some of these queries on the demo below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[<span class="symbol">::latest-product</span>]
[{<span class="symbol">::latest-product</span> [<span class="symbol">:product/title</span>]}]

<span class="comment">; ::latest-product can be requested anywhere</span>
[{<span class="symbol">::latest-product</span>
  [<span class="keyword">*</span> <span class="symbol">::latest-product</span>]}]</code></pre>
</div>
</div>
<div x-app="interactive-parser" data-parser="connect.getting-started" class="loader">
[::latest-product]
</div>
<div class="space"></div>
</div>
<div class="sect3">
<h4 id="_resolvers_with_input"><a class="anchor" href="#_resolvers_with_input"></a><a class="link" href="#_resolvers_with_input">3.3.4. Resolvers with input</a></h4>
<div class="paragraph">
<p>Next, let&#8217;s say we want to have a new attribute which is the brand of the product. Of course, we could just throw the
data there in our other resolver, but the real power of connect comes out when we start splitting the responsibilities
among resolvers, so let&#8217;s define a resolver for brand that requires an input of <code>:product/id</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.connect.getting-started2</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

(<span class="keyword">def</span> <span class="function">product-&gt;brand</span>
  {<span class="integer">1</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Taylor</span><span class="delimiter">&quot;</span></span>})

(pc/defresolver latest-product [_ _]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">::latest-product</span> [<span class="symbol">:product/id</span> <span class="symbol">:product/title</span> <span class="symbol">:product/price</span>]}]}
  {<span class="symbol">::latest-product</span> {<span class="symbol">:product/id</span>    <span class="integer">1</span>
                     <span class="symbol">:product/title</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Acoustic Guitar</span><span class="delimiter">&quot;</span></span>
                     <span class="symbol">:product/price</span> <span class="float">199.99</span>M}})

(pc/defresolver product-brand [_ {<span class="symbol">:keys</span> [product/id]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:product/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:product/brand</span>]}
  {<span class="symbol">:product/brand</span> (<span class="keyword">get</span> product-&gt;brand id)})

(<span class="keyword">def</span> <span class="function">app-registry</span> [latest-product product-brand])

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parallel-parser
    {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span> [p/map-reader
                              pc/parallel-reader
                              pc/open-ident-reader]}
     <span class="symbol">::p/mutate</span>  pc/mutate-async
     <span class="symbol">::p/plugins</span> [(pc/connect-plugin {<span class="symbol">::pc/register</span> app-registry})
                  p/error-handler-plugin
                  p/request-cache-plugin
                  p/trace-plugin]}))</code></pre>
</div>
</div>
<div x-app="interactive-parser" data-parser="connect.getting-started2" class="loader">
[{::latest-product [:product/title :product/brand]}]
</div>
<div class="space"></div>
<div class="paragraph">
<p>The input is a <code>set</code> containing the keys required on the current entity in the parsing context for the resolver to be
able to work. This is where <code>Connect</code> starts to shine because any time your query asks for a bit of data
it will try to figure it out how to satisfy that request based on the attributes that the current contextual entity <strong>already has</strong>.</p>
</div>
<div class="paragraph">
<p>More importantly: <code>Connect</code> will <strong>explore the dependency graph</strong> in order to resolve things if it needs to!
To illustrate this let&#8217;s pretend we have some external ID for the brand, and that we can derive this ID from the
brand string, pretty much just another mapping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; a silly pretend lookup</span>
(<span class="keyword">def</span> <span class="function">brand-&gt;id</span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">Taylor</span><span class="delimiter">&quot;</span></span> <span class="integer">44151</span>})

(pc/defresolver brand-id-from-name [_ {<span class="symbol">:keys</span> [product/brand]}]
  {<span class="symbol">::pc/input</span> #{<span class="symbol">:product/brand</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:product/brand-id</span>]}
  {<span class="symbol">:product/brand-id</span> (<span class="keyword">get</span> brand-&gt;id brand)})

(<span class="keyword">comment</span>
  (parser {} [{<span class="symbol">::latest-product</span> [<span class="symbol">:product/title</span> <span class="symbol">:product/brand-id</span>]}])
  <span class="comment">; =&gt; #::{:latest-product #:product{:title &quot;Acoustic Guitar&quot;, :brand-id 44151}}</span>
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that our query never said anything about the <code>:product/brand</code>. <code>Connect</code> automatically walked the path
<code>:product/id &#8594; :product/brand &#8594; :product/brand-id</code> to obtain the information desired by the query!</p>
</div>
<div class="paragraph">
<p>When a required attribute is not present in the current entity, <code>Connect</code> will look for resolvers that can fetch it,
analyze their inputs, and recursively walk backwards towards the "known data" in the context.
When a required attribute is not present in the current entity, <code>Connect</code> will calculate the possibole paths
from the data you have to the data you request, then it can use some euristic to decide which path to take
and walk this path to reach the data, if there is no possible path connect reader will return <code>::p/continue</code> to
let another reader try to handle that key. You can read more about how this works in the Index page.</p>
</div>
<div class="paragraph">
<p>Also remember that single-input resolvers can handle ident-based queries.
Thus, the following ident-join queries already work without having to define anything else:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(parser {} [{[<span class="symbol">:product/id</span> <span class="integer">1</span>] [<span class="symbol">:product/brand</span>]}])
<span class="comment">; =&gt; {[:product/id 1] #:product{:brand &quot;Taylor&quot;}}</span>

(parser {} [{[<span class="symbol">:product/brand</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Taylor</span><span class="delimiter">&quot;</span></span>] [<span class="symbol">:product/brand-id</span>]}])
<span class="comment">; =&gt; {[:product/brand &quot;Taylor&quot;] #:product{:brand-id 44151}}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_multiple_inputs"><a class="anchor" href="#_multiple_inputs"></a><a class="link" href="#_multiple_inputs">3.3.5. Multiple inputs</a></h4>
<div class="paragraph">
<p>The input to a resolver is a set, and as such you can require more than one thing as input to your resolvers.  When doing
so, of course, your resolver function will receive all of the inputs requested; however, this also means that the parsing
context needs to contain them, or there must exist other resolvers that can use what&#8217;s in the context to fill them in.</p>
</div>
<div class="paragraph">
<p>As you have seen before, the only way to provide ad-hoc information to connect is using the ident query, but in the ident
itself you can only provide one attribute at a time.</p>
</div>
<div class="paragraph">
<p>Since version <code>2.2.0-beta11</code> the ident readers from connect (<code>ident-reader</code> and <code>open-ident-reader</code>) support adding extra
context to the query using parameters, so let&#8217;s say you want to load some customer data, but wants to provide some base
information that you already have to reduce the number of resolvers called, you can issue a query like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{([<span class="symbol">:customer/id</span> <span class="integer">123</span>] {<span class="symbol">:pathom/context</span> {<span class="symbol">:customer/first-name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Foo</span><span class="delimiter">&quot;</span></span> <span class="symbol">:customer/last-name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Bar</span><span class="delimiter">&quot;</span></span>}})
  [<span class="symbol">:customer/full-name</span>]}]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_parameters"><a class="anchor" href="#_parameters"></a><a class="link" href="#_parameters">3.3.6. Parameters</a></h4>
<div class="paragraph">
<p>Parameters enable another dimension of information to be add to the request. Params have
different semantics from inputs, inputs are more a <code>dependency</code> thing, while params are
more like options. In practice the main difference is that inputs are something Pathom
will try to look up and make available, while parameters must always be provided at
query time, no auto resolution. Common cases to use parameters are: pagination, sorting,
filtering&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Let&#8217;s write a resolver that outputs a key with a sequence that can take a parameter to sort the
resulting list via user provided attribute.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(pc/defresolver instruments-list [env _]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">::instruments</span> [<span class="symbol">:instrument/id</span> <span class="symbol">:instrument/brand</span>
                                <span class="symbol">:instrument/type</span> <span class="symbol">:instrument/price</span>]}]}
  (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [<span class="keyword">sort</span>]} (<span class="keyword">-&gt;</span> env <span class="symbol">:ast</span> <span class="symbol">:params</span>)] <span class="comment">; </span><b class="conum">(1)</b>
    {<span class="symbol">::instruments</span> (cond-&gt;&gt; instruments
                     (<span class="keyword">keyword?</span> <span class="keyword">sort</span>) (<span class="keyword">sort-by</span> <span class="keyword">sort</span>))}))</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Pull the parameters from environment</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Then we can run queries like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[(<span class="symbol">::instruments</span> {<span class="symbol">:sort</span> <span class="symbol">:instrument/brand</span>})]
[(<span class="symbol">::instruments</span> {<span class="symbol">:sort</span> <span class="symbol">:instrument/price</span>})]
[(<span class="symbol">::instruments</span> {<span class="symbol">:sort</span> <span class="symbol">:instrument/type</span>})]

<span class="comment">; params with join</span>

[{(<span class="symbol">::instruments</span> {<span class="symbol">:sort</span> <span class="symbol">:instrument/price</span>})
  [<span class="symbol">:instrument/id</span>
   <span class="symbol">:instrument/brand</span>]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Try it out:</p>
</div>
<div x-app="interactive-parser" data-parser="connect.parameters" class="loader">
[(::instruments {:sort :instrument/price})]
</div>
<div class="space"></div>
</div>
<div class="sect3">
<h4 id="_n_1_queries_and_batch_resolvers"><a class="anchor" href="#_n_1_queries_and_batch_resolvers"></a><a class="link" href="#_n_1_queries_and_batch_resolvers">3.3.7. N+1 Queries and Batch resolvers</a></h4>
<div class="paragraph">
<p>When you have a to-many relation that is being resolved by a parser you will typically end up with a single query that
finds the "IDs", and then <code>N</code> more queries to fill in the details of each item in the sequence.  This is known as the
<code>N+1</code> problem, and can be a source of significant performance problems.</p>
</div>
<div class="paragraph">
<p>The solution is relatively simple in Pathom: Add the <code>request-cache-plugin</code> to the parser and include a
<code>::pc/batch? true</code> option in your resolver. Pathom then knows that it <strong>can</strong> send a sub-resolver a sequence of
inputs instead of a single one.  If your resolver
receives a sequence, then it is expected to return a <strong>vector</strong> of promised outputs instead of a single map.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
You must detect if the input is a sequence and also be ready to handle the case when it is not.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s see one example to illustrate the situation:</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This example is using Pathom async parsers.  The resolvers in async parsers can return channels that (eventually)
resolve to the result, which is why you see <code>go</code> blocks in the code.  See <a href="#AsyncParsing">Async Parsing</a> for more details.  We use them in this example so we can
"sleep" in a Javascript environment to mimic overhead in processing. In the rest of the book we recommend using the parallel parser, the reason
to use the async parser in this example is that it more easely demonstrates the n+1 issue.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.connect.batch</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
            [cljs.core.async <span class="symbol">:as</span> async <span class="symbol">:refer</span> [go]]
            [com.wsscode.pathom.profile <span class="symbol">:as</span> pp]))

(pc/defresolver list-things [_ _]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">:items</span> [<span class="symbol">:number</span>]}]}
  {<span class="symbol">:items</span> [{<span class="symbol">:number</span> <span class="integer">3</span>}
           {<span class="symbol">:number</span> <span class="integer">10</span>}
           {<span class="symbol">:number</span> <span class="integer">18</span>}]})

(pc/defresolver slow-resolver [_ {<span class="symbol">:keys</span> [number]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:number</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:number-added</span>]}
  (go
    (async/&lt;! (async/timeout <span class="integer">1000</span>))
    {<span class="symbol">:number-added</span> (<span class="keyword">inc</span> number)}))

(<span class="keyword">def</span> <span class="function">app-registry</span> [list-things slow-resolver])

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/async-parser
    {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span> [p/map-reader
                              pc/async-reader2
                              pc/open-ident-reader]}
     <span class="symbol">::p/mutate</span>  pc/mutate-async
     <span class="symbol">::p/plugins</span> [(pc/connect-plugin {<span class="symbol">::pc/register</span> app-registry})
                  p/error-handler-plugin
                  p/request-cache-plugin
                  p/trace-plugin]}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Try the example:</p>
</div>
<div x-app="interactive-parser" data-parser="connect.batch" class="loader">
[{:items [:number-added]}]
</div>
<div class="space"></div>
<div class="paragraph">
<p>You can note by the tracer that it took one second for each entry, a clear cascade,
because it had to call the <code>:number-added</code> resolver once for each item.</p>
</div>
<div class="paragraph">
<p>We can improving that by turning this into a batch resolver, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.connect.batch2</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
            [cljs.core.async <span class="symbol">:as</span> async <span class="symbol">:refer</span> [go]]))

(pc/defresolver list-things [_ _]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">:items</span> [<span class="symbol">:number</span>]}]}
  {<span class="symbol">:items</span> [{<span class="symbol">:number</span> <span class="integer">3</span>}
           {<span class="symbol">:number</span> <span class="integer">10</span>}
           {<span class="symbol">:number</span> <span class="integer">18</span>}]})

(pc/defresolver slow-resolver [_ input]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:number</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:number-added</span>]
   <span class="symbol">::pc/batch?</span> <span class="predefined-constant">true</span>}
  (go
    (async/&lt;! (async/timeout <span class="integer">1000</span>))
    <span class="comment">; the input will be sequencial if a batch oportunity happens</span>
    (<span class="keyword">if</span> (<span class="keyword">sequential?</span> input)
      <span class="comment">; this will return a list of results, this order should match the input order, like this:</span>
      <span class="comment">; [{:number-added 4}</span>
      <span class="comment">;  {:number-added 11}</span>
      <span class="comment">;  {:number-added 19}]</span>
      (mapv (<span class="keyword">fn</span> [v] {<span class="symbol">:number-added</span> (<span class="keyword">inc</span> (<span class="symbol">:number</span> v))}) input)
      <span class="comment">; the else case still handles the single input case</span>
      {<span class="symbol">:number-added</span> (<span class="keyword">inc</span> (<span class="symbol">:number</span> input))})))

(<span class="keyword">def</span> <span class="function">app-registry</span> [list-things slow-resolver])

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/async-parser
    {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span>        [p/map-reader
                                     pc/async-reader2
                                     pc/open-ident-reader]
                  <span class="symbol">::p/process-error</span> (<span class="keyword">fn</span> [env error]
                                      (js/console.error <span class="string"><span class="delimiter">&quot;</span><span class="content">ERROR</span><span class="delimiter">&quot;</span></span> error)
                                      (p/error-str error))}
     <span class="symbol">::p/mutate</span>  pc/mutate-async
     <span class="symbol">::p/plugins</span> [(pc/connect-plugin {<span class="symbol">::pc/register</span> app-registry})
                  p/error-handler-plugin
                  p/request-cache-plugin
                  p/trace-plugin]}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Try the example:</p>
</div>
<div x-app="interactive-parser" data-parser="connect.batch2" class="loader">
[{:items [:number-added]}]
</div>
<div class="space"></div>
<div class="paragraph">
<p>Note that this time the sleep of one second only happened once, this is because when Pathom is processing a list and the
resolver supports batching, the resolver will get all the inputs in a single call, so your batch resolver can get all
the items in a single iteration. The results will be cached back for each entry, this will make the other items hit the
cache instead of calling the resolver again.</p>
</div>
<div class="sect4">
<h5 id="_aligning_results"><a class="anchor" href="#_aligning_results"></a><a class="link" href="#_aligning_results">Aligning results</a></h5>
<div class="paragraph">
<p>Often times when you do a batch request to some service/api the results won&#8217;t come in
the same order of the request, also the count might not match in case some of the items
on request were invalid. To facilitate the coding of these cases Pathom provides
a helper to correctly sort the results back, for more info check the docs about
<a href="https://cljdoc.org/d/com.wsscode/pathom/CURRENT/api/com.wsscode.pathom.connect#batch-restore-sort">batch-restore-sort on cljdoc</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_connect_mutations"><a class="anchor" href="#_connect_mutations"></a><a class="link" href="#_connect_mutations">3.4. Connect mutations</a></h3>
<div class="paragraph">
<p>Using mutations from connect will give you some extra leverage by adding the mutation information to the index, this will
enable auto-complete features for explorer interfaces, and also integrates the mutation result with the connect read engine.</p>
</div>
<div class="sect3">
<h4 id="_mutations_setup"><a class="anchor" href="#_mutations_setup"></a><a class="link" href="#_mutations_setup">3.4.1. Mutations setup</a></h4>
<div class="paragraph">
<p>The mutation setup looks very much like the one from resolvers, you define then using <code>pc/defmutation</code> and
include on the registry like resolvers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.connect.mutations</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

(pc/defmutation my-mutation [env params] <span class="keyword">..</span><span class="keyword">.</span>)

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parallel-parser
    {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span> [p/map-reader
                              pc/parallel-reader
                              pc/open-ident-reader]}
     <span class="symbol">::p/mutate</span>  pc/mutate-async
     <span class="symbol">::p/plugins</span> [(pc/connect-plugin {<span class="symbol">::pc/register</span> send-message})
                  p/error-handler-plugin
                  p/request-cache-plugin
                  p/trace-plugin]}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s write a mutation with our factory.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creating_mutations"><a class="anchor" href="#_creating_mutations"></a><a class="link" href="#_creating_mutations">3.4.2. Creating mutations</a></h4>
<div class="paragraph">
<p>The <code>defmutation</code> have the same interface that we used with <code>defresolver</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.connect.mutations</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
            [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(pc/defmutation send-message [env {<span class="symbol">:keys</span> [message/text]}]
  {<span class="symbol">::pc/sym</span>    'send-message
   <span class="symbol">::pc/params</span> [<span class="symbol">:message/text</span>]
   <span class="symbol">::pc/output</span> [<span class="symbol">:message/id</span> <span class="symbol">:message/text</span>]}
  {<span class="symbol">:message/id</span>   <span class="integer">123</span>
   <span class="symbol">:message/text</span> text})

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parallel-parser
    {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span> [p/map-reader
                              pc/parallel-reader
                              pc/open-ident-reader]}
     <span class="symbol">::p/mutate</span>  pc/mutate-async
     <span class="symbol">::p/plugins</span> [(pc/connect-plugin {<span class="symbol">::pc/register</span> send-message})
                  p/error-handler-plugin
                  p/request-cache-plugin
                  p/trace-plugin]}))</code></pre>
</div>
</div>
<div x-app="interactive-parser" data-parser="connect.mutations" class="loader">
[(send-message {:message/text "Hello Clojurist!"})]
</div>
<div class="space"></div>
<div class="paragraph">
<p>The <code>::pc/params</code> is currently a non-op, but in the future it can be used to validate the mutation input, it&#8217;s format
is the same as output (considering the input can have a complex data shape). The <code>::pc/output</code> is valid and can be used
for auto-complete information on explorer tools.</p>
</div>
<div class="sect4">
<h5 id="_mutation_joins"><a class="anchor" href="#_mutation_joins"></a><a class="link" href="#_mutation_joins">Mutation joins</a></h5>
<div class="paragraph">
<p>After doing some operation, you might want to read information about the operation result. With connect
you can leverage the resolver engine to expand the information that comes from the mutation. To do that
you do a mutation join, and use that to query the information. Here is an example where we create a
new user and retrieve some server information with the output.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.connect.mutation-join</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
            [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(pc/defmutation create-user [{<span class="symbol">::keys</span> [db]} user]
  {<span class="symbol">::pc/sym</span>    'user/create
   <span class="symbol">::pc/params</span> [<span class="symbol">:user/name</span> <span class="symbol">:user/email</span>]
   <span class="symbol">::pc/output</span> [<span class="symbol">:user/id</span>]}
  (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [user/id] <span class="symbol">:as</span> new-user}
        (<span class="keyword">-&gt;</span> user
            (<span class="keyword">select-keys</span> [<span class="symbol">:user/name</span> <span class="symbol">:user/email</span>])
            (<span class="keyword">merge</span> {<span class="symbol">:user/id</span>         (random-uuid)
                    <span class="symbol">:user/created-at</span> (js/Date.)}))]
    (<span class="keyword">swap!</span> db <span class="keyword">assoc-in</span> [<span class="symbol">:users</span> id] new-user)
    {<span class="symbol">:user/id</span> id}))

(pc/defresolver user-data [{<span class="symbol">::keys</span> [db]} {<span class="symbol">:keys</span> [user/id]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:user/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:user/id</span> <span class="symbol">:user/name</span> <span class="symbol">:user/email</span> <span class="symbol">:user/created-at</span>]}
  (<span class="keyword">get-in</span> @db [<span class="symbol">:users</span> id]))

(pc/defresolver all-users [{<span class="symbol">::keys</span> [db]} _]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">:user/all</span> [<span class="symbol">:user/id</span> <span class="symbol">:user/name</span> <span class="symbol">:user/email</span> <span class="symbol">:user/created-at</span>]}]}
  (<span class="keyword">vals</span> (<span class="keyword">get</span> db <span class="symbol">:users</span>)))

(<span class="keyword">def</span> <span class="function">api-registry</span> [create-user user-data all-users])

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parallel-parser
    {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span> [p/map-reader pc/parallel-reader pc/open-ident-reader]
                  <span class="symbol">::db</span>       (<span class="keyword">atom</span> {})}
     <span class="symbol">::p/mutate</span>  pc/mutate-async
     <span class="symbol">::p/plugins</span> [(pc/connect-plugin {<span class="symbol">::pc/register</span> api-registry})
                  p/error-handler-plugin
                  p/request-cache-plugin
                  p/trace-plugin]}))</code></pre>
</div>
</div>
<div x-app="interactive-parser" data-parser="connect.mutation-join" class="loader">
[{(user/create {:user/name "Rick Sanches" :user/email "rick@morty.com"})
  [:user/id :user/name :user/created-at]}]
</div>
<div class="space"></div>
<div class="paragraph">
<p>Note that although we only return the <code>:user/id</code> from the mutation, the resolvers can walk the graph
and fetch the other requested attributes.</p>
</div>
</div>
<div class="sect4">
<h5 id="_mutation_join_globals"><a class="anchor" href="#_mutation_join_globals"></a><a class="link" href="#_mutation_join_globals">Mutation join globals</a></h5>
<div class="paragraph">
<p>Some attributes need to be in the output, even when they are not asked for. For example, if your parser is driving a
Fulcro app, the <code>:tempid</code> part of the mutation will be required for the app to remap the ids correctly. We could ask for
the user to add it on every remote query, but instead we can also define some global attributes and they
will be read every time. As in this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.connect.mutation-join-globals</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
            [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(pc/defmutation user-create [{<span class="symbol">::keys</span> [db]} user]
  {<span class="symbol">::pc/sym</span>    'user/create
   <span class="symbol">::pc/params</span> [<span class="symbol">:user/name</span> <span class="symbol">:user/email</span>]
   <span class="symbol">::pc/output</span> [<span class="symbol">:user/id</span>]}
  (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [user/id] <span class="symbol">:as</span> new-user}
        (<span class="keyword">-&gt;</span> user
            (<span class="keyword">select-keys</span> [<span class="symbol">:user/name</span> <span class="symbol">:user/email</span>])
            (<span class="keyword">merge</span> {<span class="symbol">:user/id</span>         (random-uuid)
                    <span class="symbol">:user/created-at</span> (js/Date.)}))]
    (<span class="keyword">swap!</span> db <span class="keyword">assoc-in</span> [<span class="symbol">:users</span> id] new-user)
    {<span class="symbol">:user/id</span>       id
     <span class="symbol">:app/id-remaps</span> {(<span class="symbol">:user/id</span> user) id}}))

(pc/defresolver user-data [{<span class="symbol">::keys</span> [db]} {<span class="symbol">:keys</span> [user/id]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:user/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:user/id</span> <span class="symbol">:user/name</span> <span class="symbol">:user/email</span> <span class="symbol">:user/created-at</span>]}
  (<span class="keyword">get-in</span> @db [<span class="symbol">:users</span> id]))

(pc/defresolver all-users [{<span class="symbol">::keys</span> [db]} _]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">:user/all</span> [<span class="symbol">:user/id</span> <span class="symbol">:user/name</span> <span class="symbol">:user/email</span> <span class="symbol">:user/created-at</span>]}]}
  (<span class="keyword">vals</span> (<span class="keyword">get</span> db <span class="symbol">:users</span>)))

(<span class="keyword">def</span> <span class="function">app-registry</span> [user-create user-data all-users])

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parallel-parser
    {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span>                 [p/map-reader
                                              pc/parallel-reader
                                              pc/open-ident-reader
                                              p/env-placeholder-reader]
                  <span class="symbol">::pc/mutation-join-globals</span> [<span class="symbol">:app/id-remaps</span>]
                  <span class="symbol">::p/placeholder-prefixes</span>   #{<span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;</span><span class="delimiter">&quot;</span></span>}
                  <span class="symbol">::db</span>                       (<span class="keyword">atom</span> {})}
     <span class="symbol">::p/mutate</span>  pc/mutate-async
     <span class="symbol">::p/plugins</span> [(pc/connect-plugin {<span class="symbol">::pc/register</span> app-registry})
                  p/error-handler-plugin
                  p/request-cache-plugin
                  p/trace-plugin]}))</code></pre>
</div>
</div>
<div x-app="interactive-parser" data-parser="connect.mutation-join-globals" class="loader">
[{(user/create {:user/id "TMP_ID" :user/name "Rick Sanches" :user/email "rick@morty.com"})
  [:user/id :user/name :user/created-at]}]
</div>
<div class="space"></div>
<div class="paragraph">
<p>So in case of fulcro apps you can use the <code>:fulcro.client.primitives/tempids</code> as the global and have that pass though.</p>
</div>
</div>
<div class="sect4">
<h5 id="_mutation_output_context"><a class="anchor" href="#_mutation_output_context"></a><a class="link" href="#_mutation_output_context">Mutation output context</a></h5>
<div class="paragraph">
<p>Mutation context allow the mutation caller to provide extra data to be used as context
information to futher processing in the mutation response.</p>
</div>
<div class="paragraph">
<p>During UI development, sometimes you may want to load some data in response of the mutation, but the mutation output
doens&#8217;t have enough context although the UI does (because it has a much bigger view at the client data). For
those cases the UI can send some params to the mutation so those are available for traversing in the mutation
response.</p>
</div>
<div class="paragraph">
<p>To demonstrate this check the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.connect.mutation-context</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
            [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(pc/defmutation create-user [{<span class="symbol">::keys</span> [db]} user]
  {<span class="symbol">::pc/sym</span>    'user/create
   <span class="symbol">::pc/params</span> [<span class="symbol">:user/name</span> <span class="symbol">:user/email</span>]
   <span class="symbol">::pc/output</span> [<span class="symbol">:user/id</span>]}
  (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [user/id] <span class="symbol">:as</span> new-user}
        (<span class="keyword">-&gt;</span> user
            (<span class="keyword">select-keys</span> [<span class="symbol">:user/name</span> <span class="symbol">:user/email</span>])
            (<span class="keyword">merge</span> {<span class="symbol">:user/id</span>         (random-uuid)
                    <span class="symbol">:user/created-at</span> (js/Date.)}))]
    (<span class="keyword">swap!</span> db <span class="keyword">assoc-in</span> [<span class="symbol">:users</span> id] new-user)
    {<span class="symbol">:user/id</span> id}))

(pc/defresolver user-data [{<span class="symbol">::keys</span> [db]} {<span class="symbol">:keys</span> [user/id]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:user/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:user/id</span> <span class="symbol">:user/name</span> <span class="symbol">:user/email</span> <span class="symbol">:user/created-at</span>]}
  (<span class="keyword">get-in</span> @db [<span class="symbol">:users</span> id]))

(pc/defresolver all-users [{<span class="symbol">::keys</span> [db]} _]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">:user/all</span> [<span class="symbol">:user/id</span> <span class="symbol">:user/name</span> <span class="symbol">:user/email</span> <span class="symbol">:user/created-at</span>]}]}
  (<span class="keyword">vals</span> (<span class="keyword">get</span> db <span class="symbol">:users</span>)))

(pc/defresolver n++ [_ {<span class="symbol">:keys</span> [number/value]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:number/value</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:number/value++</span>]}
  {<span class="symbol">:number/value++</span> (<span class="keyword">inc</span> value)})

(<span class="keyword">def</span> <span class="function">api-registry</span> [create-user user-data all-users n++])

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parallel-parser
    {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span> [p/map-reader pc/parallel-reader pc/open-ident-reader]
                  <span class="symbol">::db</span>       (<span class="keyword">atom</span> {})}
     <span class="symbol">::p/mutate</span>  pc/mutate-async
     <span class="symbol">::p/plugins</span> [(pc/connect-plugin {<span class="symbol">::pc/register</span> api-registry})
                  p/error-handler-plugin
                  p/request-cache-plugin
                  p/trace-plugin]}))</code></pre>
</div>
</div>
<div x-app="interactive-parser" data-parser="connect.mutation-context" class="loader">
[{(user/create {:user/id "TMP_ID"
                :user/name "Rick Sanches"
                :user/email "rick@morty.com"
                :pathom/context {:number/value 123}})
  [:number/value :number/value++]}]
</div>
<div class="space"></div>
<div class="paragraph">
<p>One real use case for this feature would be in a Fulcro app, when you send some mutation
but the result needs to update some component elsewere (and the required data is known
by the client, but not by the original mutation result).</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_async_mutations"><a class="anchor" href="#_async_mutations"></a><a class="link" href="#_async_mutations">3.4.3. Async mutations</a></h4>
<div class="paragraph">
<p>This section is no longer nescessary, the main recommendation now is to use the <code>parallel-parser</code> which is async, no
changes needed to write async mutations, all you gotta know is that you can return channels from your mutations
and they will be properly coordinated.</p>
</div>
<div class="paragraph">
<p>Here is an example of doing some mutation operations using async features.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.connect.mutation-async</span>
  (<span class="symbol">:require</span> [cljs.core.async <span class="symbol">:as</span> async <span class="symbol">:refer</span> [go]]
            [com.wsscode.common.async-cljs <span class="symbol">:refer</span> [go-catch &lt;!p &lt;?]]
            [com.wsscode.pathom.book.util.indexeddb <span class="symbol">:as</span> db]
            [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
            [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">defn</span> <span class="function">adapt-user</span> [user]
  (<span class="keyword">-&gt;</span> (<span class="keyword">into</span> {} (<span class="keyword">map</span> (<span class="keyword">fn</span> [[k v]] [(<span class="keyword">keyword</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span> (<span class="keyword">name</span> k)) v])) (<span class="keyword">dissoc</span> user <span class="symbol">::db/key</span>))
      (<span class="keyword">assoc</span> <span class="symbol">:user/id</span> (<span class="symbol">::db/key</span> user))))

(pc/defmutation user-create [{<span class="symbol">::keys</span> [db]} user]
  {<span class="symbol">::pc/sym</span>    'user/create
   <span class="symbol">::pc/params</span> [<span class="symbol">:user/name</span> <span class="symbol">:user/email</span>]
   <span class="symbol">::pc/output</span> [<span class="symbol">:user/id</span>]}
  (go
    (<span class="keyword">let</span> [db      (&lt;? db)
          user-id (<span class="keyword">-&gt;</span> user
                      (<span class="keyword">select-keys</span> [<span class="symbol">:user/name</span> <span class="symbol">:user/email</span>])
                      (<span class="keyword">merge</span> {<span class="symbol">:user/created-at</span> (js/Date.)})
                      (<span class="keyword">-&gt;&gt;</span> (db/create! {<span class="symbol">::db/db</span> db <span class="symbol">::db/store-name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">users</span><span class="delimiter">&quot;</span></span>}))
                      &lt;?)]
      {<span class="symbol">:user/id</span>       user-id
       <span class="symbol">:app/id-remaps</span> {(<span class="symbol">:user/id</span> user) user-id}})))

(pc/defresolver user-by-id [{<span class="symbol">::keys</span> [db]} {<span class="symbol">:keys</span> [user/id]}]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:user/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:user/id</span> <span class="symbol">:user/name</span> <span class="symbol">:user/email</span> <span class="symbol">:user/created-at</span>]}
  (go
    <span class="comment">; reading from indexeddb</span>
    (<span class="keyword">let</span> [db (&lt;? db)]
      (<span class="keyword">-&gt;</span> (db/read-object {<span class="symbol">::db/db</span> db <span class="symbol">::db/store-name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">users</span><span class="delimiter">&quot;</span></span>} id) &lt;?
          adapt-user))))

<span class="comment">; let's make an access to all users</span>
(pc/defresolver all-users [{<span class="symbol">::keys</span> [db]} _]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">:user/all</span> [<span class="symbol">:user/id</span> <span class="symbol">:user/name</span> <span class="symbol">:user/email</span> <span class="symbol">:user/created-at</span>]}]}
  (go
    (<span class="keyword">let</span> [db (&lt;? db)]
      (<span class="keyword">-&gt;&gt;</span> (db/scan-store {<span class="symbol">::db/db</span> db <span class="symbol">::db/store-name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">users</span><span class="delimiter">&quot;</span></span>})
           (async/into []) &lt;?
           (mapv adapt-user)
           (<span class="keyword">hash-map</span> <span class="symbol">:user/all</span>)))))

<span class="comment">; list all our app resolvers and mutations</span>
(<span class="keyword">def</span> <span class="function">app-registry</span> [user-create user-by-id all-users])

(<span class="keyword">def</span> <span class="function">db-settings</span>
  {<span class="symbol">::db/db-name</span>    <span class="string"><span class="delimiter">&quot;</span><span class="content">connectAsyncDemo</span><span class="delimiter">&quot;</span></span>
   <span class="symbol">::db/migrations</span> [{<span class="symbol">::db/stores</span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">users</span><span class="delimiter">&quot;</span></span> {<span class="symbol">::db/keys</span>    <span class="symbol">::db/auto-increment</span>
                                           <span class="symbol">::db/indexes</span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> {<span class="symbol">::db/unique</span> <span class="predefined-constant">false</span>}}}}}]})

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parallel-parser
    {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span>               [p/map-reader
                                            pc/parallel-reader
                                            pc/open-ident-reader
                                            p/env-placeholder-reader]
                  <span class="symbol">::p/placeholder-prefixes</span> #{<span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;</span><span class="delimiter">&quot;</span></span>}
                  <span class="symbol">::pc/mutation-join-globals</span> [<span class="symbol">:app/id-remaps</span>]
                  <span class="symbol">::db</span>                       (db/setup-db db-settings)}
     <span class="symbol">::p/mutate</span>  pc/mutate-async
     <span class="symbol">::p/plugins</span> [(pc/connect-plugin {<span class="symbol">::pc/register</span> app-registry})
                  p/error-handler-plugin
                  p/request-cache-plugin
                  p/trace-plugin]}))</code></pre>
</div>
</div>
<div x-app="interactive-parser" data-parser="connect.mutation-async" class="loader">
[{(user/create {:user/id "TMP_ID" :user/name "Rick Sanches" :user/email "rick@morty.com"})
  [:user/id :user/name :user/created-at]}]
</div>
<div class="space"></div>
<div class="paragraph">
<p>Using the same query/mutation interface, we replaced the underlying implementation from an atom to a indexeddb database.</p>
</div>
<div class="paragraph">
<p>You can do the same to target any type of API you can access.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_shared_resolvers"><a class="anchor" href="#_shared_resolvers"></a><a class="link" href="#_shared_resolvers">3.5. Shared resolvers</a></h3>
<div class="paragraph">
<p>Since version <code>2.2.0</code> Pathom adds support to describe resolvers as pure maps and <code>register</code> those resolvers in
your system, making possible to write easy to share resolvers in a library format.</p>
</div>
<div class="sect3">
<h4 id="_resolver_data_format"><a class="anchor" href="#_resolver_data_format"></a><a class="link" href="#_resolver_data_format">3.5.1. Resolver data format</a></h4>
<div class="paragraph">
<p>The map format contains all the information needed for a resolver to run, this means a
symbol to name it, the input, the output and the lamba to run the computation. This
is considered an open map, any extra keys will end up in the index and can be read
later.</p>
</div>
<div class="paragraph">
<p>Here is an example of how you can specific a resolver using the map format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">some-resolver</span>
  {<span class="symbol">::pc/sym</span>     `some-resolver <span class="comment">; this is important! we need to name each resolver, prefer qualified symbols</span>
   <span class="symbol">::pc/input</span>   #{<span class="symbol">:customer/id</span>}
   <span class="symbol">::pc/output</span>  [<span class="symbol">:customer/id</span> <span class="symbol">:customer/name</span> <span class="symbol">:customer/email</span>]
   <span class="symbol">::pc/resolve</span> (<span class="keyword">fn</span> [env input] <span class="keyword">..</span><span class="keyword">.</span>)})</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s very similar to using <code>defresolver</code>, you just add the key <code>::pc/resolve</code> to define the
runner function of it. Note that using this helper <strong>you don&#8217;t have to provide the <code>::pc/sym</code> key</strong>, its
added automatically for you.</p>
</div>
<div class="paragraph">
<p>You can also create using the <code>pc/resolver</code> helper function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">some-resolver</span>
  (pc/resolver `some-resolver
    {<span class="symbol">::pc/input</span> #{<span class="symbol">:customer/id</span>}
     <span class="symbol">::pc/output</span> [<span class="symbol">:customer/id</span> <span class="symbol">:customer/name</span> <span class="symbol">:customer/email</span>]}
    (<span class="keyword">fn</span> [env input] <span class="keyword">..</span><span class="keyword">.</span>)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This just returns the same map of the previous example.</p>
</div>
<div class="paragraph">
<p>And using the final macro helper (recommended way):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(pc/defresolver some-resolver
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:customer/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:customer/id</span> <span class="symbol">:customer/name</span> <span class="symbol">:customer/email</span>]}
  (<span class="keyword">fn</span> [env input] <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mutation_data_format"><a class="anchor" href="#_mutation_data_format"></a><a class="link" href="#_mutation_data_format">3.5.2. Mutation data format</a></h4>
<div class="paragraph">
<p>Mutations are similar as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">send-message-mutation</span>
  {<span class="symbol">::pc/sym</span>    `send-message-mutation
   <span class="symbol">::pc/params</span> #{<span class="symbol">:message/body</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:message/id</span> <span class="symbol">:message/body</span> <span class="symbol">:message/created-at</span>]
   <span class="symbol">::pc/mutate</span> (<span class="keyword">fn</span> [env params] <span class="keyword">..</span><span class="keyword">.</span>)})</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see it&#8217;s very similar to using <code>defresolver</code>, you just add the key <code>::pc/resolve</code> to define the
runner function of it.</p>
</div>
<div class="paragraph">
<p>Using the helper:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">send-message-mutation</span>
  (pc/mutation `send-message-mutation
    {<span class="symbol">::pc/params</span> #{<span class="symbol">:message/body</span>}
     <span class="symbol">::pc/output</span> [<span class="symbol">:message/id</span> <span class="symbol">:message/body</span> <span class="symbol">:message/created-at</span>]}
    (<span class="keyword">fn</span> [env params] <span class="keyword">..</span><span class="keyword">.</span>)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>And using the final macro helper (recommended way):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(pc/defmutation send-message-mutation
  {<span class="symbol">::pc/params</span> #{<span class="symbol">:message/body</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:message/id</span> <span class="symbol">:message/body</span> <span class="symbol">:message/created-at</span>]}
  (<span class="keyword">fn</span> [env params] <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mutations must be included in the register to be available, like resolvers.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_code_register_code"><a class="anchor" href="#_using_code_register_code"></a><a class="link" href="#_using_code_register_code">3.5.3. Using <code>register</code></a></h4>
<div class="paragraph">
<p>Once you have your maps ready you can register then using the connect <code>register</code> function to the index.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">-&gt;</span> {}
    <span class="comment">; register the resolver we created previously</span>
    (pc/register some-resolver)

    <span class="comment">; same method works for mutations</span>
    (pc/register send-message-mutation)

    <span class="comment">; you can also send collections to register many at once</span>
    (pc/register [some-resolver send-message-mutation])

    <span class="comment">; collections will be recursivelly processed, so this is valid too:</span>
    (pc/register [some-resolver [send-message-mutation]]))

<span class="comment">; in the end the index will have the information combined of all the resolvers and mutations</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are a library author, consider defining each resolver/mutation as its own symbol
and then create another symbol that is vector combining your features, this way you
make easy for your users to just get the vector, but still allow then to cherry pick
which operations he wants to pull if he doesn&#8217;t want it all.</p>
</div>
</div>
<div class="sect3">
<h4 id="_plugins_with_resolvers"><a class="anchor" href="#_plugins_with_resolvers"></a><a class="link" href="#_plugins_with_resolvers">3.5.4. Plugins with resolvers</a></h4>
<div class="paragraph">
<p>It&#8217;s also possible for plugins to declare resolvers and mutations so they get installed
when the plugin is used. To do that your plugin must provide the <code>::pc/register</code> key
on the plugin map, and you also need to use the <code>pc/connect-plugin</code>, this plugin will
make the instalation, here is an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="keyword">..</span><span class="keyword">.</span>

(<span class="keyword">def</span> <span class="function">my-plugin-with-resolvers</span>
 {<span class="symbol">::pc/register</span> [some-resolver send-message-mutation]})

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/env</span>     (<span class="keyword">fn</span> [env]
                           (<span class="keyword">merge</span>
                             {<span class="symbol">::p/reader</span> [p/map-reader pc/reader pc/open-ident-reader]}
                             env))
             <span class="symbol">::p/mutate</span>  pc/mutate-async
             <span class="symbol">::p/plugins</span> [(pc/connect-plugin) <span class="comment">; make sure connect-plugin is here, it's order doesn't matter</span>
                          my-plugin-with-resolvers]}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>And that&#8217;s it, the resolvers will be registered right after the parser is defined.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_a_thread_pool_for_parallel_resolvers"><a class="anchor" href="#_using_a_thread_pool_for_parallel_resolvers"></a><a class="link" href="#_using_a_thread_pool_for_parallel_resolvers">3.6. Using a thread pool for parallel resolvers</a></h3>
<div class="paragraph">
<p>When you run Pathom in Clojure with the parallel connect, the resolver functions are
running inside core.async <code>go</code> blocks. In case of CLJS most IO is done async, making
this a non-issue, but if you are on Java environment and doing blocking IO, this means
the code is doing IO on <code>go</code> blocks, which is a no no.</p>
</div>
<div class="paragraph">
<p>If you can switch to some library that does async IO that&#8217;s the best option, but if you
can&#8217;t or wont now, Pathom provides a thread pool helper so you can tell the engine to
run the resolvers there to avoid blocking the <code>go</code> blocks.</p>
</div>
<div class="paragraph">
<p>Here is an example of how to setup a thread pool (clj only!):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parallel-parser
    {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span>               [p/map-reader
                                            pc/parallel-reader
                                            pc/open-ident-reader
                                            p/env-placeholder-reader]
                  <span class="comment">; setup the thread pool</span>
                  <span class="symbol">::pc/thread-pool</span>         (pc/create-thread-pool (async/chan <span class="integer">200</span>))
                  <span class="symbol">::p/placeholder-prefixes</span> #{<span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;</span><span class="delimiter">&quot;</span></span>}}
     <span class="symbol">::p/mutate</span>  pc/mutate-async
     <span class="symbol">::p/plugins</span> [(pc/connect-plugin {<span class="symbol">::pc/register</span> []})
                  p/error-handler-plugin
                  p/request-cache-plugin
                  p/trace-plugin]}))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_advanced_connect_details"><a class="anchor" href="#_advanced_connect_details"></a><a class="link" href="#_advanced_connect_details">3.7. Advanced Connect Details</a></h3>
<div class="sect3">
<h4 id="_connect_readers"><a class="anchor" href="#_connect_readers"></a><a class="link" href="#_connect_readers">3.7.1. Connect readers</a></h4>
<div class="sect4">
<h5 id="_code_pc_parallel_reader_code"><a class="anchor" href="#_code_pc_parallel_reader_code"></a><a class="link" href="#_code_pc_parallel_reader_code"><code>pc/parallel-reader</code></a></h5>
<div class="paragraph">
<p>Parallel reader from connect is implemented to work with the <code>paralle-parser</code>. This reader
is capable of detecting attribute dependencies, execute multiple in parallel
and coordinate the return, including back tracking for secondary paths. Here is how it works:</p>
</div>
<div class="paragraph">
<p>Getting back to the connect basic idea, that we expand information from a context, to illustrate
this case let&#8217;s have the following set of resolvers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(pc/defresolver movie-details [env input]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:movie/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:movie/id</span> <span class="symbol">:movie/title</span> <span class="symbol">:movie/release-date</span>]}
  <span class="keyword">..</span><span class="keyword">.</span>)

(pc/defresolver movie-rating [env input]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:movie/id</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:movie/rating</span>]}
  <span class="keyword">..</span><span class="keyword">.</span>)

(pc/defresolver movie-title-prefixed [env input]
  {<span class="symbol">::pc/input</span>  #{<span class="symbol">:movie/title</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">:movie/title-prefixed</span>]}
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that we have two resolvers that depend on a <code>:movie/id</code> and one that depends on <code>:movie/title</code>.</p>
</div>
<div class="paragraph">
<p>Now given the query: <code>[{[:movie/id 42] [:movie/title-prefixed]}]</code></p>
</div>
<div class="paragraph">
<p>First we use the ident query to create the context with a <code>:movie/id</code>, for the attribute <code>:movie/title-prefixed</code>
the <code>parallel-reader</code> will be invoked. The first thing the reader has to do is compute a plan to
reach the attribute considering the data it has now, it does it by recursively iterating over
the <code>::pc/index-oir</code> until it reaches some available dependency or gives up because there is
no possible path.</p>
</div>
<div class="paragraph">
<p>Most cases (specially for small apis) there will be only a single path, and this is the case
for our example the result of <code>pc/compute-path</code> is this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">#{[[<span class="symbol">:movie/title</span> `movie-details] [<span class="symbol">:movie/title-prefixed</span> `movie-title-prefixed]]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The format returned by <code>pc/compute-path</code> is a vector of paths, each path is a vector of
tuples, the tuple contains the attribute reason (why that resolver is been called) and the
resolver symbol that will be used to fetch that attribute, this makes the path from the
available data to the attribute requested, this is the plan.</p>
</div>
<div class="paragraph">
<p>For details on the path selection algorithm in cases of multiple options check the
<a href="#paths_selection">paths selection</a> section.</p>
</div>
<div class="paragraph">
<p>Ok, now let&#8217;s see how it behaves when you have multiple attributes to process, this is
the new query, this time let&#8217;s try using the interactive parser, run the query and
check in the tracing how it goes (I added a 100ms delay to each resolver call so its easier to see):</p>
</div>
<div x-app="interactive-parser" data-parser="parallel-reader.demo" class="loader">
[{[:movie/id 42]
  [:movie/id
   :movie/title
   :movie/release-date
   :movie/rating
   :movie/title-prefixed]}]
</div>
<div class="space"></div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Try changing the order of the attributes and see what happens, for example if
you put <code>:movie/title-prefixed</code> at start you will this attribute been responsible
for the title fetching and itself.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This is what&#8217;s happening for each attribute:</p>
</div>
<div class="paragraph">
<p><code>:movie/id</code>: this data is already in the entity context, this means it will be read from memory and will not even invoke
the parallel reader</p>
</div>
<div class="paragraph">
<p><code>:movie/title</code>: this attribute is not on entity, so it will create the plan to call <code>movie-details</code>
from this plan we can also compute all the attributes we will incorporate in the call chain
(by combining the outs of all the resolvers in the path), we store this information as a waiting list.
The waiting list on this case is: <code>[:movie/id :movie/title :movie/releast-date]</code>. The processing of
attributes continues in parallel while the resolver is called.</p>
</div>
<div class="paragraph">
<p><code>:movie/release-date</code>: this attribute is not on entity, but it is in the waiting list, so
the parser will ignore it for now and skip to process the next one.</p>
</div>
<div class="paragraph">
<p><code>:movie/rating</code>: this attribute is not in entity, neighter in the waiting list, so we can
call the resolver for it immediatly, and the plan output (<code>[:movie/rating]</code>) is appended to the
waiting list.</p>
</div>
<div class="paragraph">
<p><code>:movie/title-prefixed</code>: like the rating this is not in entity or waiting, so we compute
the plan and execute, the plan is again:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">#{[[<span class="symbol">:movie/title</span> `movie-details] [<span class="symbol">:movie/title-prefixed</span> `movie-title-prefixed]]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>But <code>movie-details</code> is already running because of <code>:movie/title</code>, when the <code>parallel-reader</code>
calls a resolver, it actually caches it immediatly as a promise channel in the request cache,
so when we hit the same resolver with the same input, it hits the cache, getting a hold
of the promise channel, so the process continues normally with only one actual call to
the resolver, but two listeners on the promise channel (and any posterior cache hit would
get to this same promise channel). This is how the data fetch is coordinated across
the attributes, placeholder nodes are also supported and optimized to avoid repeated
calls to resolvers.</p>
</div>
<div class="paragraph">
<p>Another difference is during processing of sequences, the parallel parser uses core.async
<code>pipeline</code> to process each sequence with a parallelism concurrency of 10.</p>
</div>
<div class="sect5">
<h6 id="paths_selection"><a class="anchor" href="#paths_selection"></a><a class="link" href="#paths_selection">Path selection</a></h6>
<div class="paragraph">
<p>In case there are multiple possible paths Pathom has to decide which path to take,
the current implementation chooses the path with less weight, that calculation is made
in this way:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Every resolver starts with weight 1 (this is recorded per instance)</p>
</li>
<li>
<p>Once a resolver is called, it’s execution time is recorded and updated in the map using the formula: new-value = (old-value + last-time) * 0.5</p>
</li>
<li>
<p>If a resolver call throws an exception, double it’s weight</p>
</li>
<li>
<p>Every time we mention some resolver in a path calculation its weight is reduced by one.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If you like to make your own sorting of the plan, you can set the key <code>::pc/sort-plan</code> in your
environment, and Pathom will call this function sort the results, it takes the environment
and the plan (which is a set like demonstrate in the previous section).</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_code_pc_reader2_code"><a class="anchor" href="#_code_pc_reader2_code"></a><a class="link" href="#_code_pc_reader2_code"><code>pc/reader2</code></a></h5>
<div class="paragraph">
<p>This reader leverages some tecniques that were develop during the
creationg of the parallel reader, things like path choosing and
backtracking.</p>
</div>
</div>
<div class="sect4">
<h5 id="_code_pc_async_reader2_code"><a class="anchor" href="#_code_pc_async_reader2_code"></a><a class="link" href="#_code_pc_async_reader2_code"><code>pc/async-reader2</code></a></h5>
<div class="paragraph">
<p>Like <code>pc/reader2</code> but knows how to handle async processing inside.</p>
</div>
</div>
<div class="sect4">
<h5 id="_code_pc_reader_code_deprecated"><a class="anchor" href="#_code_pc_reader_code_deprecated"></a><a class="link" href="#_code_pc_reader_code_deprecated"><code>pc/reader</code> [DEPRECATED]</a></h5>
<div class="paragraph">
<p>DEPRECATED: use <code>pc/reader2</code> instead</p>
</div>
<div class="paragraph">
<p>The main <code>Connect</code> reader. This will look up the attribute in the index and try to resolve it, recursively if necessary.</p>
</div>
</div>
<div class="sect4">
<h5 id="_code_pc_async_reader_code_deprecated"><a class="anchor" href="#_code_pc_async_reader_code_deprecated"></a><a class="link" href="#_code_pc_async_reader_code_deprecated"><code>pc/async-reader</code> [DEPRECATED]</a></h5>
<div class="paragraph">
<p>DEPRECATED: use <code>pc/async-reader2</code> instead</p>
</div>
<div class="paragraph">
<p>Like <code>pc/reader</code> but knows how to handle async processing inside.</p>
</div>
</div>
<div class="sect4">
<h5 id="connect-ident-reader"><a class="anchor" href="#connect-ident-reader"></a><a class="link" href="#connect-ident-reader"><code>pc/ident-reader</code></a></h5>
<div class="paragraph">
<p>The <code>ident-reader</code> is used to resolve ident-based queries by establishing an initial context from the ident.
When an ident query reaches this reader it will check the index to see if the ident key is present on in the indexed
<a href="#connect-index-idents">idents</a>.</p>
</div>
<div class="paragraph">
<p>Since version <code>2.2.0-beta11</code> this reader also supports extra context provision using the param <code>:pathom/context</code>, here is how to send
extra data to it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{([<span class="symbol">:user/id</span> <span class="integer">123</span>] {<span class="symbol">:pathom/context</span> {<span class="symbol">:other/data</span> <span class="integer">123</span>}})
  [<span class="symbol">:user/id</span> <span class="symbol">:user/name</span> <span class="symbol">:other/data</span>]}]</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_code_pc_open_ident_reader_code"><a class="anchor" href="#_code_pc_open_ident_reader_code"></a><a class="link" href="#_code_pc_open_ident_reader_code"><code>pc/open-ident-reader</code></a></h5>
<div class="paragraph">
<p>Like <code>ident-reader</code>, but not constrained to the indexed idents, this will create a context from any ident.</p>
</div>
</div>
<div class="sect4">
<h5 id="_code_pc_index_reader_code"><a class="anchor" href="#_code_pc_index_reader_code"></a><a class="link" href="#_code_pc_index_reader_code"><code>pc/index-reader</code></a></h5>
<div class="paragraph">
<p>This reader exposes the index itself with the name <code>::pc/indexes</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_understanding_the_indexes"><a class="anchor" href="#_understanding_the_indexes"></a><a class="link" href="#_understanding_the_indexes">3.7.2. Understanding the indexes</a></h4>
<div class="paragraph">
<p><code>Connect</code> maintains a few indexes containg information about the <code>resolvers</code> and the
relationships on attributes. <code>Connect</code> will look up the index in the environment, on the
key <code>:com.wsscode.pathom.connect/indexes</code>, which is a map containing the indexes</p>
</div>
<div class="paragraph">
<p>In order to explain the different indexes we&#8217;ll look at the index generated by our
example in the getting started section:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">::pc/index-resolvers</span>
 {get-started/latest-product
  {<span class="symbol">::pc/sym</span>     get-started/latest-product
   <span class="symbol">::pc/input</span>   #{}
   <span class="symbol">::pc/output</span>  [{<span class="symbol">::get-started/latest-product</span> [<span class="symbol">:product/id</span>
                                                <span class="symbol">:product/title</span>
                                                <span class="symbol">:product/price</span>]}]
   <span class="symbol">::pc/resolve</span> (<span class="keyword">fn</span> <span class="keyword">..</span><span class="keyword">.</span>)}

  get-started/product-brand
  {<span class="symbol">::pc/sym</span>     get-started/product-brand
   <span class="symbol">::pc/input</span>   #{<span class="symbol">:product/id</span>}
   <span class="symbol">::pc/output</span>  [<span class="symbol">:product/brand</span>]
   <span class="symbol">::pc/resolve</span> (<span class="keyword">fn</span> <span class="keyword">..</span><span class="keyword">.</span>)}

  get-started/brand-id-from-name
  {<span class="symbol">::pc/sym</span>     get-started/brand-id-from-name
   <span class="symbol">::pc/input</span>   #{<span class="symbol">:product/brand</span>}
   <span class="symbol">::pc/output</span>  [<span class="symbol">:product/brand-id</span>]
   <span class="symbol">::pc/resolve</span> (<span class="keyword">fn</span> <span class="keyword">..</span><span class="keyword">.</span>)}}

 <span class="symbol">::pc/index-oir</span>
 {<span class="symbol">:get-started/latest-product</span> {#{} #{get-started/latest-product}}
  <span class="symbol">:product/brand</span>              {#{<span class="symbol">:product/id</span>} #{get-started/product-brand}}
  <span class="symbol">:product/brand-id</span>           {#{<span class="symbol">:product/brand</span>} #{get-started/brand-id-from-name}}}

 <span class="symbol">::pc/index-io</span>
 {#{}               {<span class="symbol">:get-started/latest-product</span> <span class="error">#</span><span class="symbol">:product</span>{<span class="symbol">:id</span> {} <span class="symbol">:title</span> {} <span class="symbol">:price</span> {}}}
  #{<span class="symbol">:product/id</span>}    {<span class="symbol">:product/brand</span> {}}
  #{<span class="symbol">:product/brand</span>} {<span class="symbol">:product/brand-id</span> {}}}

 <span class="symbol">::pc/idents</span>
 #{<span class="symbol">:product/brand</span> <span class="symbol">:product/id</span>}}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_code_index_resolvers_code"><a class="anchor" href="#_code_index_resolvers_code"></a><a class="link" href="#_code_index_resolvers_code"><code>index-resolvers</code></a></h5>
<div class="paragraph">
<p>This is a raw index of available resolvers, it&#8217;s a map <code>resolver-sym &#8594; resolver-data</code>.
<code>resolver-data</code> is any information relevant that you want to add about that resolver. Any
key that you adding during <code>pc/add</code> will end up on this map, also <code>Connect</code> will
add the key <code>::pc/sym</code> automatically, which is the same symbol you added. If you
want to access the data for a <code>resolver</code>, <code>Connect</code> provides a helper function for that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(pc/resolver-data env-or-indexes `product-brand)
<span class="comment">; =&gt; {::pc/sym     get-started/product-brand</span>
<span class="comment">;     ::pc/input   #{:product/id}</span>
<span class="comment">;     ::pc/output  [:product/brand]</span>
<span class="comment">;     ::pc/resolve (fn ...)}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_code_index_oir_code"><a class="anchor" href="#_code_index_oir_code"></a><a class="link" href="#_code_index_oir_code"><code>index-oir</code></a></h5>
<div class="paragraph">
<p>This index stands for <code>output &#8594; input &#8594; resolver</code>. It&#8217;s the index used for the <code>Connect</code>
reader to look up attributes. This index is built by looking at the input/output for the
resolver when you add it. It will save that resolver
as a path to each output attribute, given that input. It basically inverts the order of things:
it keys the output attribute to all of the potential "starting points".</p>
</div>
<div class="paragraph">
<p>Let&#8217;s do an exercise and see how connect traverses this index in a practical example:</p>
</div>
<div class="paragraph">
<p>Given we have this index (oir):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.connect.index-oir-example</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

(<span class="keyword">def</span> <span class="function">indexes</span>
  (<span class="keyword">-&gt;</span> {}
      (pc/add 'thing-by-id {<span class="symbol">::pc/input</span>  #{<span class="symbol">:id</span>}
                            <span class="symbol">::pc/output</span> [<span class="symbol">:id</span> <span class="symbol">:name</span> <span class="symbol">:color</span>]})
      (pc/add 'thing-by-name {<span class="symbol">::pc/input</span>  #{<span class="symbol">:name</span>}
                              <span class="symbol">::pc/output</span> [<span class="symbol">:id</span> <span class="symbol">:name</span> <span class="symbol">:color</span>]})))

<span class="comment">; index-oir:</span>
'{<span class="symbol">:name</span>  {#{<span class="symbol">:id</span>} #{thing-by-id}}
  <span class="symbol">:color</span> {#{<span class="symbol">:id</span>}   #{thing-by-id}
          #{<span class="symbol">:name</span>} #{thing-by-name}}
  <span class="symbol">:id</span>    {#{<span class="symbol">:name</span>} #{thing-by-name}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now if you try to run the query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[<span class="symbol">:name</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we look in the index for <code>:name</code>, and we get <code>{#{:id} #{thing-by-id}}</code>, now we try
to match the current entity attribute keys with the sets to see if we have enough
data to call any of them. If we don&#8217;t it will fail because we don&#8217;t have
enough data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{[<span class="symbol">:id</span> <span class="integer">123</span>] [<span class="symbol">:name</span>]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>So, if we start with an ident, our initial context is <code>{:id 123}</code>. This time we have the <code>:id</code>, so
it will match with the input set <code>#{:id}</code>, and will call the resolver <code>thing-by-id</code> with
that input to figure out the name. Connect uses <a href="#atom-entities">atom entities</a>: when it
gets the return value from the resolver it merges it back into the context entities, making all data
returned from the resolver available to access new attributes as needed.</p>
</div>
</div>
<div class="sect4">
<h5 id="_code_index_io_code"><a class="anchor" href="#_code_index_io_code"></a><a class="link" href="#_code_index_io_code"><code>index-io</code></a></h5>
<div class="paragraph">
<p>The auto-complete index, <code>input &#8594; output</code>. This index accumulates the reach for
each single attribute on the index. By walking this information we can know ahead of
time all attribute possibilities we can fetch from a given attribute.</p>
</div>
<div class="paragraph">
<p>If I have a <code>:product/id</code>, what can I reach from it? Looking at the index, the <code>:product/id</code>
itself can provide the <code>:product/brand</code>. But if I have access to <code>:product/brand</code> it means
I also have access to whatever <code>:product/brand</code> can provide. By doing multiple iterations
(until there are no new attributes) we end up knowing that <code>:product/id</code> can provide the
attributes <code>:product/brand</code> and <code>:product/brand-id</code>. And this is how autocomplete is
done via the <code>index-io</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_code_index_mutations_code"><a class="anchor" href="#_code_index_mutations_code"></a><a class="link" href="#_code_index_mutations_code"><code>index-mutations</code></a></h5>
<div class="paragraph">
<p>This index contains the mutation definitions, its similar to the <code>index-resolvers</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="connect-index-idents"><a class="anchor" href="#connect-index-idents"></a><a class="link" href="#connect-index-idents"><code>idents</code></a></h5>
<div class="paragraph">
<p>The <code>idents</code> index contain information about which single attributes can be used to access
some information. This index is used on <a href="#connect-ident-reader">ident-reader</a> and on
<code>OgE</code> to provide auto-complete options for idents. Any time you add a resolver that has
a single input, that input attribute is added on the <code>idents</code> index.</p>
</div>
</div>
<div class="sect4">
<h5 id="_code_autocomplete_ignore_code"><a class="anchor" href="#_code_autocomplete_ignore_code"></a><a class="link" href="#_code_autocomplete_ignore_code"><code>autocomplete-ignore</code></a></h5>
<div class="paragraph">
<p>This index is for a more advanced usage. Currently it&#8217;s only used by the <code>GraphQL</code> integration.
In the <code>GraphQL</code> integration we leverage the fact that types have a fixed set of attributes
and add that into the index. The problem is that the types thenselves are not valid entries
for the query, then <code>autocomplete-ignore</code> is a way to make those things be ignored in
the auto-complete. You probably only need this if you are building the index in some
custom way.</p>
</div>
</div>
<div class="sect4">
<h5 id="_merging_indexes_todo"><a class="anchor" href="#_merging_indexes_todo"></a><a class="link" href="#_merging_indexes_todo">Merging indexes #TODO</a></h5>

</div>
</div>
</div>
<div class="sect2">
<h3 id="_exploration_with_pathom_viz_todo"><a class="anchor" href="#_exploration_with_pathom_viz_todo"></a><a class="link" href="#_exploration_with_pathom_viz_todo">3.8. Exploration with Pathom Viz #TODO</a></h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_getting_started_on_pathom_core_engine"><a class="anchor" href="#_getting_started_on_pathom_core_engine"></a><a class="link" href="#_getting_started_on_pathom_core_engine">4. Getting Started on Pathom core engine</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_query_notation_introduction"><a class="anchor" href="#_query_notation_introduction"></a><a class="link" href="#_query_notation_introduction">4.1. Query Notation Introduction</a></h3>
<div class="paragraph">
<p>A query is a vector that lists the items you want. A keyword requests a scalar (opaque) value, and
a map indicates a to-many or to-one join (resolved at runtime using database content).</p>
</div>
<div class="paragraph">
<p>Queries are always "relative" to some starting context (which is typically supplied via parameters
or by a top-level join).</p>
</div>
<div class="paragraph">
<p>If you want to obtain the name and age of "some" person:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[<span class="symbol">:person/name</span> <span class="symbol">:person/age</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to obtain a person&#8217;s name and the street of their address you might write this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[<span class="symbol">:person/name</span> {<span class="symbol">:person/address</span> [<span class="symbol">:address/street</span>]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>where we imagine that the underlying database has some kind of normalization that needs to be traversed in order to satisfy the address data.</p>
</div>
<div class="paragraph">
<p>The result of running a query is a map containing the result (in the same recursive shape as the query):</p>
</div>
<div class="paragraph">
<p>Running <code>[:person/name :person/age]</code> against the person "Sam" might give:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sam</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/age</span> <span class="integer">32</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Running <code>[:person/name {:person/address [:address/street]}]</code> against that same person might give:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sam</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/address</span> {<span class="symbol">:address/street</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">111 Main St.</span><span class="delimiter">&quot;</span></span>}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <strong>query</strong> establishes the request and expectation. <strong>Interpreting and satisfying</strong> these queries from some arbitrary data source
is the job of a query parser/interpreter. This library gives you tools for quickly building the latter.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parsing_context"><a class="anchor" href="#_parsing_context"></a><a class="link" href="#_parsing_context">4.2. Parsing Context</a></h3>
<div class="paragraph">
<p>The elements of a graph query are relative: they have a contextual meaning.  If you ask for a person&#8217;s name, the implication
is that you are querying a "person entity"; however, the other required bit of information is <strong>which person</strong>.  Thus,
elements of a query cannot be fulfilled they are rooted in a context.  This applies to joins as well (e.g. what is the current person&#8217;s
address?), but once you&#8217;ve resolved the context of the <strong>root</strong> of some graph query the joins simply describe navigation
from <strong>that context</strong> (the person) to another (their address) via a relation that is either already described in the underlying
data source itself, or in code you provide that can figure it out.</p>
</div>
<div class="paragraph">
<p>As the parser moves through a query like <code>[:person/name {:person/address [:address/street]}]</code> it first starts
with some context (e.g. "Sam").  When it finds a join it processes the subquery against a new context (e.g. Sam&#8217;s address)
to give the result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sam</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/address</span> {<span class="symbol">:address/street</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">111 Main St.</span><span class="delimiter">&quot;</span></span>}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>So, there is always a <strong>context</strong> at any given point when parsing a query. This context is either established at startup
by resolving a specific entity, or is the entity (or entities if to-many) that have been reached by processing the joins
of the query.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parsing_environment_and_the_reader"><a class="anchor" href="#_parsing_environment_and_the_reader"></a><a class="link" href="#_parsing_environment_and_the_reader">4.3. Parsing Environment and The Reader</a></h3>
<div class="paragraph">
<p>The parsing environment is simply a map that carries along data while parsing (and can be augmented as you go). It
establishes the meaning of the "current context", can contain anything you wish (via namespaced keywords), and can be
seen in any code that you plug in to process the query.</p>
</div>
<div class="paragraph">
<p>There are some predefined (namespaced) keys that have special meaning to the parser. In particular
<code>:com.wsscode.pathom.core/reader</code> can be used to supply reader(s) for the parser to use.  The <code>reader</code> can be a map from
attributes to functions, a plain function, or even a vector of functions. It is asked to read the value for the elements
of the query using the current environment. We&#8217;ll expand on that as we go, or you can read more in the <a href="#Readers">Readers section</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Core"><a class="anchor" href="#Core"></a><a class="link" href="#Core">5. Pathom Core Engine</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_parsers"><a class="anchor" href="#_parsers"></a><a class="link" href="#_parsers">5.1. Parsers</a></h3>
<div class="sect3">
<h4 id="_serial_parser"><a class="anchor" href="#_serial_parser"></a><a class="link" href="#_serial_parser">5.1.1. Serial parser</a></h4>
<div class="paragraph">
<p>TODO: explain serial parser internals</p>
</div>
</div>
<div class="sect3">
<h4 id="_async_parser"><a class="anchor" href="#_async_parser"></a><a class="link" href="#_async_parser">5.1.2. Async parser</a></h4>
<div class="paragraph">
<p>TODO: explain async parser internals</p>
</div>
</div>
<div class="sect3">
<h4 id="Parallel-parser"><a class="anchor" href="#Parallel-parser"></a><a class="link" href="#Parallel-parser">5.1.3. Parallel parser</a></h4>
<div class="paragraph">
<p>TODO: explain parallel parser internals</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Readers"><a class="anchor" href="#Readers"></a><a class="link" href="#Readers">5.2. Readers</a></h3>
<div class="paragraph">
<p>A reader is a function that will process a single entry from the query. For example, given the following query:
<code>[:name :age]</code>. If you ask an <code>om.next</code> parser to read this the reader function will be called twice; once for <code>:name</code> and another one for <code>:age</code>. Note that in the case of joins, the parser will only be called for the join entry, but not for it&#8217;s children (not automatically), for example: given the query <code>[:name :age {:parent [:name :gender]}]</code>. The reader function will be called 3 times now, one for <code>:name</code>, one for <code>:age</code> and one for <code>:parent</code>, when reading <code>:parent</code>, your reader code is responsible for checking that it has a children query, and do a recursive call (or anything else you want to do to handle this join). During this documentation, we are going to see many ways to implement those readers.</p>
</div>
<div class="paragraph">
<p>Please note the following differences between <code>om.next</code> readers and <code>pathom</code> readers: In <code>om.next</code> a parse read functions has the following signature: <code>(fn [env dispatch-key params])</code>. In <code>pathom</code> we use a smaller version instead, which is: <code>(fn [env])</code>. The <code>env</code> already contains the <code>dispatch-key</code> and <code>params</code>, so there is no loss of information.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">get-in</span> env [<span class="symbol">:ast</span> <span class="symbol">:dispatch-key</span>]) <span class="comment">; =&gt; dispatch-key</span>
(<span class="keyword">get-in</span> env [<span class="symbol">:ast</span> <span class="symbol">:params</span>]) <span class="comment">; =&gt; params</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, in <code>om.next</code> you need to return the value wrapped in <code>{:value "your-content"}</code>. In <code>pathom</code> this wrapping is done automatically for you: just return the final value.</p>
</div>
<div class="paragraph">
<p>Readers can be 1-arity function, maps, or vectors. See <a href="#map-dispatcher">Map dispatcher</a> and <a href="#vector-dispatcher">Vector dispacher</a> for information on those respectively.</p>
</div>
<div class="paragraph">
<p>Here is a formal Clojure Spec definiton for a <code>pathom</code> reader:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(s/def <span class="symbol">::reader-map</span> (s/map-of <span class="keyword">keyword?</span> <span class="symbol">::reader</span>))
(s/def <span class="symbol">::reader-seq</span> (s/coll-of <span class="symbol">::reader</span> <span class="symbol">:kind</span> <span class="keyword">vector?</span>))
(s/def <span class="symbol">::reader-fn</span> (s/fspec <span class="symbol">:args</span> (s/cat <span class="symbol">:env</span> <span class="symbol">::env</span>)
                            <span class="symbol">:ret</span> any?))

(s/def <span class="symbol">::reader</span>
  (s/or <span class="symbol">:fn</span> <span class="symbol">::reader-fn</span>
        <span class="symbol">:map</span> <span class="symbol">::reader-map</span>
        <span class="symbol">:list</span> <span class="symbol">::reader-seq</span>))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_functions_as_readers"><a class="anchor" href="#_functions_as_readers"></a><a class="link" href="#_functions_as_readers">5.2.1. Functions as Readers</a></h4>
<div class="paragraph">
<p>These are quite simply a function that receive the env and resolve the read. More than one reader can exist in a chain, and the special return value <code>::p/continue</code> allows a reader to indicate it cannot resolve the given property (to continue processing the chain). Returning any value (including <code>nil</code>) you&#8217;ve resolved the property to that value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.fn-dispatch</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">defn</span> <span class="function">read-value</span> [{<span class="symbol">:keys</span> [ast]}]
  (<span class="keyword">let</span> [<span class="keyword">key</span> (<span class="keyword">get</span> ast <span class="symbol">:dispatch-key</span>)]
    (<span class="keyword">case</span> <span class="keyword">key</span>
      <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Saul</span><span class="delimiter">&quot;</span></span>
      <span class="symbol">:family</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Goodman</span><span class="delimiter">&quot;</span></span>
      <span class="comment">; good pratice: return ::p/continue when your reader is unable</span>
      <span class="comment">; to handle the request</span>
      <span class="symbol">::p/continue</span>)))

(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> read-value})]}))

(parser {} [<span class="symbol">:name</span> <span class="symbol">:family</span>])
<span class="comment">; =&gt; {:name &quot;Saul&quot; :family &quot;Goodman&quot;}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="map-dispatcher"><a class="anchor" href="#map-dispatcher"></a><a class="link" href="#map-dispatcher">5.2.2. Maps as Readers</a></h4>
<div class="paragraph">
<p>Since it is very common to want to resolve queries from a fixed set of possibilities we support defining a map as a reader. This is really just a "dispatch table" to functions that will receive <code>env</code>.  We can re-write the previous example as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.reader-map-dispatch</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">user-reader</span>
  {<span class="symbol">:name</span>   (<span class="keyword">fn</span> [_] <span class="string"><span class="delimiter">&quot;</span><span class="content">Saul</span><span class="delimiter">&quot;</span></span>)
   <span class="symbol">:family</span> (<span class="keyword">fn</span> [_] <span class="string"><span class="delimiter">&quot;</span><span class="content">Goodman</span><span class="delimiter">&quot;</span></span>)})

(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> user-reader})]}))

(parser {} [<span class="symbol">:name</span> <span class="symbol">:family</span>])
<span class="comment">; =&gt; {:name &quot;Saul&quot; :family &quot;Goodman&quot;}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The built-in Map Reader will return <code>::p/continue</code> if the map it is looking in does not contain the key for the attribute being resolved. This allows it to be safely used in a vector of readers.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="vector-dispatcher"><a class="anchor" href="#vector-dispatcher"></a><a class="link" href="#vector-dispatcher">5.2.3. Vectors of Readers [aka composed readers]</a></h4>
<div class="paragraph">
<p>Using a vector for a reader is how you define a chain of readers. This allows you to define readers that serve a particular purpose. For example, some library author might want to supply readers to compose into your parser, or you might have different modules of database-specific readers that you&#8217;d like to keep separate.</p>
</div>
<div class="paragraph">
<p>When pathom is trying to resolve a given attribute (say <code>:person/name</code>) in some context (say against the "Sam" entity) it will start at the beginning of the reader chain. The first reader will be asked to resolve the attribute.   If the reader can handle the value then it will be returned and no other readers will be consulted.  If it instead returns the special value <code>::p/continue</code> it is signalling that it could not resolve it (map readers do this if the attribute key is not in their map).  When this happens the next reader in the chain will be tried.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.reader-vector-dispatch</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

<span class="comment">; a map dispatcher for the :name key</span>
(<span class="keyword">def</span> <span class="function">name-reader</span>
  {<span class="symbol">:name</span>   (<span class="keyword">fn</span> [_] <span class="string"><span class="delimiter">&quot;</span><span class="content">Saul</span><span class="delimiter">&quot;</span></span>)})

<span class="comment">; a map dispatcher for the :family key</span>
(<span class="keyword">def</span> <span class="function">family-reader</span>
  {<span class="symbol">:family</span> (<span class="keyword">fn</span> [_] <span class="string"><span class="delimiter">&quot;</span><span class="content">Goodman</span><span class="delimiter">&quot;</span></span>)})

(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [name-reader family-reader]})]}))

(parser {} [<span class="symbol">:name</span> <span class="symbol">:family</span> <span class="symbol">:other</span>])
<span class="comment">; =&gt; {:name &quot;Saul&quot;, :family &quot;Goodman&quot;, :other :com.wsscode.pathom.core/not-found}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If no reader in the chain returns a value (all readers reeturn <code>::p/continue</code>), then <code>::p/not-found</code> will be returned.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
When you write your readers you should always remember to return <code>::p/continue</code> when you can&#8217;t handle a given key. This way your reader will play nice in composition scenarios.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_the_map_reader"><a class="anchor" href="#_the_map_reader"></a><a class="link" href="#_the_map_reader">5.2.4. The Map Reader</a></h4>
<div class="paragraph">
<p>Not all things need to be computed.  Very often the current context will already have attributes that were read during
some prior step (for example, a computed attribute might have read an entire entity from the database and made it the
current context). The map reader plugin is a plugin that has the following behavior:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the attribute requested exists in the current parsing context (with any value, even nil), it returns it.</p>
</li>
<li>
<p>If the attribute is missing, it returns <code>::p/continue</code>, which is an indication to move to the next reader in the chain.</p>
</li>
<li>
<p>If the attribute is present, it properly returns the value.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The map reader is also capable of resolving relations (if present in the context). For example, if there is a join in the query
and a vector of data at that join key in the context, then it will attempt to fulfill the subquery of the join.</p>
</div>
<div class="paragraph">
<p>The map reader is almost always inserted into a reader chain because it is so common to read clumps of things from a database
into the context and resolve them one by one as the query parsing proceeds.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Entities"><a class="anchor" href="#Entities"></a><a class="link" href="#Entities">5.3. Entities</a></h3>
<div class="paragraph">
<p>An entity to <code>pathom</code> is the graph node that is tracked as the current context, and from which information (attributes and graph edges to other entities) can be derived.  The current entity needs to be "map-like": It should work with all normal map-related functions like <code>get</code>, <code>contains?</code>, etc.</p>
</div>
<div class="paragraph">
<p>As Pathom parses the query it tracks the current entity in the environment at key <code>::p/entity</code>. This makes it easier to write more reusable and flexible readers as we&#8217;ll see later.</p>
</div>
<div class="sect3">
<h4 id="_using_code_p_entity_code"><a class="anchor" href="#_using_code_p_entity_code"></a><a class="link" href="#_using_code_p_entity_code">5.3.1. Using <code>p/entity</code></a></h4>
<div class="paragraph">
<p>The <code>p/entity</code> function exists as a convenience for pulling the current entity from the parsing environment:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom-docs.using-entity</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">defn</span> <span class="function">read-attr</span> [env]
  (<span class="keyword">let</span> [e (p/entity env)
        k (<span class="keyword">get-in</span> env [<span class="symbol">:ast</span> <span class="symbol">:dispatch-key</span>])]
    (<span class="keyword">if</span> (<span class="keyword">contains?</span> e k)
      (<span class="keyword">get</span> e k)
      <span class="symbol">::p/continue</span>)))

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [read-attr]})]}))

<span class="comment">; we send the entity using ::p/entity key on environment</span>
(parser {<span class="symbol">::p/entity</span> <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Rick</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">60</span>}} [<span class="symbol">:character/name</span> <span class="symbol">:character/age</span> <span class="symbol">:character/foobar</span>])
<span class="comment">; =&gt; #:character{:name &quot;Rick&quot;, :age 60, :foobar :com.wsscode.pathom.core/not-found}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the code above is a partial implementation of the <a href="#MapReader">map-dispatcher</a>.</p>
</div>
<div class="paragraph">
<p>The <code>map-reader</code> just has the additional ability to understand how to walk a map that has a tree shape that already "fits" our query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom-docs.using-entity-map-reader</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> p/map-reader})]}))

<span class="comment">; we send the entity using ::p/entity key on environment</span>
(parser {<span class="symbol">::p/entity</span> <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Rick</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">60</span>
                                <span class="symbol">:family</span> [<span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Morty</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">14</span>}
                                         <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Summer</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">17</span>}]
                                <span class="symbol">:first-episode</span> <span class="error">#</span><span class="symbol">:episode</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Pilot</span><span class="delimiter">&quot;</span></span> <span class="symbol">:season</span> <span class="integer">1</span> <span class="symbol">:number</span> <span class="integer">1</span>}}}
        [<span class="symbol">:character/name</span> <span class="symbol">:character/age</span>
         {<span class="symbol">:character/family</span> [<span class="symbol">:character/age</span>]}
         {<span class="symbol">:character/first-episode</span> [<span class="symbol">:episode/name</span> <span class="symbol">:episode/number</span>]}])
<span class="comment">; =&gt;</span>
<span class="comment">; #:character{:name &quot;Rick&quot;,</span>
<span class="comment">;             :age 60,</span>
<span class="comment">;             :family [#:character{:age 14} #:character{:age 17}],</span>
<span class="comment">;             :first-episode #:episode{:name &quot;Pilot&quot;, :number 1}}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that you understand where the entity context is tracked I encourage you to check the <code>p/map-reader</code> implementation. It&#8217;s not very long and will give you a better understanding of all of the concepts covered so far.</p>
</div>
</div>
<div class="sect3">
<h4 id="_understanding_joins"><a class="anchor" href="#_understanding_joins"></a><a class="link" href="#_understanding_joins">5.3.2. Understanding Joins</a></h4>
<div class="paragraph">
<p>The other significant task when processing a graph query is walking a graph edge to another entity (or entities) when we find a join.</p>
</div>
<div class="paragraph">
<p>The subquery for a join is in the <code>:query</code> of the environment. Essentially it is a recursive step where we run the parser on the subquery while replacing the "current entity":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">join</span> [entity {<span class="symbol">:keys</span> [parser query] <span class="symbol">:as</span> env}]
  (parser (<span class="keyword">assoc</span> env <span class="symbol">::p/entity</span> entity) query))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The real pathom implementation handles some additional scenarios: like the <strong>empty sub-query</strong> case (it returns the full entity), the special <code>*</code> query (so you can combine the whole entity + extra computed attributes), and union queries.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use <code>p/join</code> to "invent" a relation that can then be queried:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom-docs.using-entity-map-reader</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">rick</span>
  <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span>          <span class="string"><span class="delimiter">&quot;</span><span class="content">Rick</span><span class="delimiter">&quot;</span></span>
              <span class="symbol">:age</span>           <span class="integer">60</span>
              <span class="symbol">:family</span>        [<span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Morty</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">14</span>}
                              <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Summer</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">17</span>}]
              <span class="symbol">:first-episode</span> <span class="error">#</span><span class="symbol">:episode</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Pilot</span><span class="delimiter">&quot;</span></span> <span class="symbol">:season</span> <span class="integer">1</span> <span class="symbol">:number</span> <span class="integer">1</span>}})

(<span class="keyword">def</span> <span class="function">char-name-&gt;voice</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Relational information representing edges from character names to actors</span><span class="delimiter">&quot;</span></span>
  {<span class="string"><span class="delimiter">&quot;</span><span class="content">Rick</span><span class="delimiter">&quot;</span></span>   <span class="error">#</span><span class="symbol">:actor</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Justin Roiland</span><span class="delimiter">&quot;</span></span> <span class="symbol">:nationality</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">US</span><span class="delimiter">&quot;</span></span>}
   <span class="string"><span class="delimiter">&quot;</span><span class="content">Morty</span><span class="delimiter">&quot;</span></span>  <span class="error">#</span><span class="symbol">:actor</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Justin Roiland</span><span class="delimiter">&quot;</span></span> <span class="symbol">:nationality</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">US</span><span class="delimiter">&quot;</span></span>}
   <span class="string"><span class="delimiter">&quot;</span><span class="content">Summer</span><span class="delimiter">&quot;</span></span> <span class="error">#</span><span class="symbol">:actor</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Spencer Grammer</span><span class="delimiter">&quot;</span></span> <span class="symbol">:nationality</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">US</span><span class="delimiter">&quot;</span></span>}})

(<span class="keyword">def</span> <span class="function">computed</span>
  {<span class="symbol">:character/voice</span> <span class="comment">; support an invented join attribute</span>
   (<span class="keyword">fn</span> [env]
     (<span class="keyword">let</span> [{<span class="symbol">:character/keys</span> [<span class="keyword">name</span>]} (p/entity env)
           voice (<span class="keyword">get</span> char-name-&gt;voice <span class="keyword">name</span>)]
       (p/join voice env)))})

(<span class="keyword">def</span> <span class="function">parser</span>
  <span class="comment">; process with map-reader first, then try with computed</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [p/map-reader computed]})]}))

(parser {<span class="symbol">::p/entity</span> rick} <span class="comment">; start with rick (as current entity)</span>
        '[<span class="symbol">:character/name</span>
          {<span class="symbol">:character/voice</span> [<span class="symbol">:actor/name</span>]}
          {<span class="symbol">:character/family</span> [<span class="keyword">*</span> <span class="symbol">:character/voice</span>]}])</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are three different scenarios demonstrated in the above query:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Using the invented join property in a normal join. This allows for a subquery that constrains the data returned (from the actor in this case).</p>
</li>
<li>
<p>Using the <code>*</code> in a query, which returns all "known" attributes of the "current contextual" entity.</p>
</li>
<li>
<p>Using an additional (non-joined) <code>:character/voice</code> with <code>*</code> "adds in" that additional information. When a property is queried for that is processed via <code>p/join</code> then the entire entity will be returned even though there is no subquery.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_dependent_attributes"><a class="anchor" href="#_dependent_attributes"></a><a class="link" href="#_dependent_attributes">5.3.3. Dependent Attributes</a></h4>
<div class="paragraph">
<p>When computing attributes it is possible that you might need some other attribute for the current context that is <strong>also</strong> computed. You could hard-code a solution, but that would create all sorts of static code problems that could be difficult to manage as your code evolves: changes to the readers, for example, could easily break it and lead to difficult bugs.</p>
</div>
<div class="paragraph">
<p>Instead, it is important that readers be able to resolve attributes they need from the "current context" in an abstract manner (i.e. the same way that they query itself is being resolved). The <code>p/entity</code> function has an additional arity for handling this exact case. You pass it a list of attributes that should be "made available" on the current entity, and it will use the parser to ensure that they are there (if possible):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">let</span> [e (p/entity env [<span class="symbol">:x</span>])]
   <span class="comment">; e now has :x on it if possible, even if it is computed elsewhere</span>
   <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows this in context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.entity-attribute-dependency</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">computed</span>
  {<span class="symbol">:greet</span>
   (<span class="keyword">fn</span> [env]
     (<span class="keyword">let</span> [{<span class="symbol">:character/keys</span> [<span class="keyword">name</span>]} (p/entity env)]
       (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="delimiter">&quot;</span></span>)))

   <span class="symbol">:invite</span>
   (<span class="keyword">fn</span> [env]
     <span class="comment">; requires the computed property `:greet`, which might not have been computed into the current context yet.</span>
     (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [greet]} (p/entity env [<span class="symbol">:greet</span>])]
       (<span class="keyword">str</span> greet <span class="string"><span class="delimiter">&quot;</span><span class="content"> Come to visit us in Neverland!</span><span class="delimiter">&quot;</span></span>)))})

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [p/map-reader
                                                     computed]})]}))

(parser {<span class="symbol">::p/entity</span> <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Mary</span><span class="delimiter">&quot;</span></span>}}
        [<span class="symbol">:invite</span>])
<span class="comment">; =&gt; {:invite &quot;Hello Mary! Come to visit us in Neverland!&quot;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There is a variant <code>p/entity!</code> that raises an error if your desired attributes are not found. It&#8217;s recommended to use the enforced version if you need the given attributes, as it will give your user a better error message.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.entity-attribute-enforce</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">computed</span>
  {<span class="symbol">:greet</span>
   (<span class="keyword">fn</span> [env]
     <span class="comment">; enfore the character/name to be present, otherwise raises error, try removing</span>
     <span class="comment">; the attribute from the entity and see what happens</span>
     (<span class="keyword">let</span> [<span class="keyword">name</span> (p/entity-attr! env <span class="symbol">:character/name</span>)]
       (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="delimiter">&quot;</span></span>)))

   <span class="symbol">:invite</span>
   (<span class="keyword">fn</span> [env]
     <span class="comment">; now we are enforcing the attribute to be available, otherwise raise an error</span>
     <span class="comment">; try changing the :greet to :greete and run the file, you will see the error</span>
     (<span class="keyword">let</span> [greet (p/entity-attr! env <span class="symbol">:greet</span>)]
       (<span class="keyword">str</span> greet <span class="string"><span class="delimiter">&quot;</span><span class="content"> Come to visit us in Neverland!</span><span class="delimiter">&quot;</span></span>)))})

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [p/map-reader
                                                     computed]})]}))

(parser {<span class="symbol">::p/entity</span> <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Mary</span><span class="delimiter">&quot;</span></span>}}
        [<span class="symbol">:invite</span>])
<span class="comment">; =&gt; {:invite &quot;Hello Mary! Come to visit us in Neverland!&quot;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If the parse fails on an enforced attribute you will get an exception. For example, if the current entity were <code>#:character{:nam "Mary"}</code> we&#8217;d see:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">CompilerException clojure.lang.ExceptionInfo<span class="error">:</span> Entity attributes #{<span class="symbol">:character/name</span>} could <span class="keyword">not</span> be realized <span class="error">#</span><span class="symbol">:com.wsscode.pathom.core</span>{<span class="symbol">:entity</span> <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:nam</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Mary</span><span class="delimiter">&quot;</span></span>}, <span class="symbol">:path</span> [<span class="symbol">:invite</span> <span class="symbol">:greet</span>], <span class="symbol">:missing-attributes</span> #{<span class="symbol">:character/name</span>}}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
If computed attributes require IO or intense computation you should consider adding caching to improve parsing performance. Remember that a given query might traverse the same node more than once! Imagine a query that asks for your friends and co-workers. When there is this kind of overlap the same computational code may run more than once. See <a href="#RequestCaching">Request Caching</a> for more details.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="atom-entities"><a class="anchor" href="#atom-entities"></a><a class="link" href="#atom-entities">5.3.4. Atom entities</a></h4>
<div class="paragraph">
<p>As you move from node to node, you can choose to wrap the new contextual entity in an atom. This can be used as a narrow kind of caching mechanism that allows for a reader to add information into the current entity as it computes it, but which is valid for only
the processing of the current entity (is lost as soon as the next join is followed). Therefore, this won&#8217;t help with the overhead of re-visiting the same entity more than once when processing different parts of the same query.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The built-in function <code>p/entity</code> always returns a Clojure map, if the entity is an atom it will deref it automatically.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is an example using an entity atom:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.entities.atom-entities</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {}))

(<span class="keyword">def</span> <span class="function">sample-item</span>
  {<span class="symbol">:id</span> <span class="integer">42</span>
   <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Some Product</span><span class="delimiter">&quot;</span></span>
   <span class="symbol">:description</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">This should be a cool product.</span><span class="delimiter">&quot;</span></span>})

(<span class="keyword">defn</span> <span class="function">item-reader</span> [{<span class="symbol">:keys</span> [ast] <span class="symbol">:as</span> env}]
  <span class="error">#</span>?(<span class="symbol">:clj</span> (Thread/sleep <span class="integer">1000</span>))
  (<span class="keyword">-&gt;</span> (p/swap-entity! env <span class="keyword">merge</span> sample-item)
      (<span class="keyword">get</span> (<span class="symbol">:key</span> ast))))

(<span class="keyword">comment</span>
  (<span class="keyword">time</span>
    (parser {<span class="symbol">::p/entity</span> (<span class="keyword">atom</span> {})
             <span class="symbol">::p/reader</span> {<span class="symbol">:id</span> item-reader <span class="symbol">:name</span> item-reader <span class="symbol">:description</span> item-reader}}
      [<span class="symbol">:id</span> <span class="symbol">:name</span> <span class="symbol">:description</span>]))
  <span class="comment">; since we are always hitting the expensive reader, each entry has to spend a second</span>

  <span class="comment">; &quot;Elapsed time: 3013.386195 msecs&quot;</span>
  <span class="comment">; =&gt; {:id 42, :name &quot;Some Product&quot;, :description &quot;This should be a cool product.&quot;}</span>

  (<span class="keyword">time</span>
    (parser {<span class="symbol">::p/entity</span> (<span class="keyword">atom</span> {})
             <span class="symbol">::p/reader</span> [p/map-reader
                         {<span class="symbol">:id</span> item-reader <span class="symbol">:name</span> item-reader <span class="symbol">:description</span> item-reader}]}
      [<span class="symbol">:id</span> <span class="symbol">:name</span> <span class="symbol">:description</span>]))
  <span class="comment">; now, adding the map-reader to the game will allow it to check on the entity first,</span>
  <span class="comment">; making the cached entity effective.</span>

  <span class="comment">;&quot;Elapsed time: 1006.479409 msecs&quot;</span>
  <span class="comment">;=&gt; {:id 42, :name &quot;Some Product&quot;, :description &quot;This should be a cool product.&quot;}</span>
  )</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_union_queries"><a class="anchor" href="#_union_queries"></a><a class="link" href="#_union_queries">5.3.5. Union queries</a></h4>
<div class="paragraph">
<p>Union queries allow us to handle edges that lead to heterogeneous nodes. For example a to-many relation for media that could result in a book or movie. Following such an edge requires that we have a different <strong>subquery</strong> depending on what we <strong>actually</strong> find in the database.</p>
</div>
<div class="paragraph">
<p>Here is an example where we want to use a query that will search to find a user, a movie or a book:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.entity-union</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">search-results</span>
  [{<span class="symbol">:type</span> <span class="symbol">:user</span>
    <span class="symbol">:user/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Jack Sparrow</span><span class="delimiter">&quot;</span></span>}
   {<span class="symbol">:type</span> <span class="symbol">:movie</span>
    <span class="symbol">:movie/title</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Ted</span><span class="delimiter">&quot;</span></span>
    <span class="symbol">:movie/year</span> <span class="integer">2012</span>}
   {<span class="symbol">:type</span> <span class="symbol">:book</span>
    <span class="symbol">:book/title</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">The Joy of Clojure</span><span class="delimiter">&quot;</span></span>}])

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [p/map-reader]})]}))

(parser {<span class="symbol">::p/entity</span> {<span class="symbol">:search</span> search-results}
         <span class="comment">; here we set where pathom should look on the entity to determine the union path</span>
         <span class="symbol">::p/union-path</span> <span class="symbol">:type</span>}
        [{<span class="symbol">:search</span> {<span class="symbol">:user</span> [<span class="symbol">:user/name</span>]
                   <span class="symbol">:movie</span> [<span class="symbol">:movie/title</span>]
                   <span class="symbol">:book</span> [<span class="symbol">:book/title</span>]}}])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, unions need to have a way to determine which path to go based on the entity at hand. In the example above we used the <code>:type</code> (a key on the entity) to determine which branch to follow.
The value of <code>::p/union-path</code> can be a keyword (from something inside entity or a computed attribute) or a function (that takes <code>env</code> and returns the correct key (e.g. <code>:book</code>) to use for the union query).</p>
</div>
<div class="paragraph">
<p>If you want <code>::p/union-path</code> to be more contextual you can of course set it in the <code>env</code> during the join process, as in the next example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.entity-union-contextual</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">search-results</span>
  [{<span class="symbol">:type</span> <span class="symbol">:user</span>
    <span class="symbol">:user/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Jack Sparrow</span><span class="delimiter">&quot;</span></span>}
   {<span class="symbol">:type</span> <span class="symbol">:movie</span>
    <span class="symbol">:movie/title</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Ted</span><span class="delimiter">&quot;</span></span>
    <span class="symbol">:movie/year</span> <span class="integer">2012</span>}
   {<span class="symbol">:type</span> <span class="symbol">:book</span>
    <span class="symbol">:book/title</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">The Joy of Clojure</span><span class="delimiter">&quot;</span></span>}])

(<span class="keyword">def</span> <span class="function">search</span>
  {<span class="symbol">:search</span>
   (<span class="keyword">fn</span> [env]
     <span class="comment">; join-seq is the same as join, but for sequences, note we set the ::p/union-path</span>
     <span class="comment">; here. This is more common since the *method* of determining type will vary for</span>
     <span class="comment">; different queries and data.</span>
     (p/join-seq (<span class="keyword">assoc</span> env <span class="symbol">::p/union-path</span> <span class="symbol">:type</span>) search-results))})

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [search
                                                     p/map-reader]})]}))

(parser {}
        [{<span class="symbol">:search</span> {<span class="symbol">:user</span> [<span class="symbol">:user/name</span>]
                   <span class="symbol">:movie</span> [<span class="symbol">:movie/title</span>]
                   <span class="symbol">:book</span> [<span class="symbol">:book/title</span>]}}])</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is something beautiful about having an immutable environment; you can make changes with confidence that it will not affect indirect points of the parsing process.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_error_handling"><a class="anchor" href="#_error_handling"></a><a class="link" href="#_error_handling">5.4. Error handling</a></h3>
<div class="paragraph">
<p>By default, pathom parser will stop if some exception occurs during the parsing process. This is often undesirable if some node fails you still can return the other ones that succeed. You can use the <code>error-handler-plugin</code>. This plugin will wrap each read call with a try-catch block, and in case an error occurs, a value of <code>::p/reader-error</code> will be placed in that node, while details of it will go in a separate tree, but at the same path. Better an example to demonstrate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.error-handling</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">computed</span>
  <span class="comment">; create a handle key that will trigger an error when called</span>
  {<span class="symbol">:trigger-error</span>
   (<span class="keyword">fn</span> [_]
     (<span class="keyword">throw</span> (ex-info <span class="string"><span class="delimiter">&quot;</span><span class="content">Error triggered</span><span class="delimiter">&quot;</span></span> {<span class="symbol">:foo</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span>})))})

<span class="comment">; a reader that just flows, until it reaches a leaf</span>
(<span class="keyword">defn</span> <span class="function">flow-reader</span> [{<span class="symbol">:keys</span> [query] <span class="symbol">:as</span> env}]
  (<span class="keyword">if</span> query
    (p/join env)
    <span class="symbol">:leaf</span>))

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [computed flow-reader]})
                          <span class="comment">; add the error handler plugin</span>
                          p/error-handler-plugin]}))

(parser {} [{<span class="symbol">:go</span> [<span class="symbol">:key</span> {<span class="symbol">:nest</span> [<span class="symbol">:trigger-error</span> <span class="symbol">:other</span>]}
                  <span class="symbol">:trigger-error</span>]}])
<span class="comment">; =&gt;</span>
<span class="comment">; {:go {:key :leaf</span>
<span class="comment">;       :nest {:trigger-error :com.wsscode.pathom.core/reader-error</span>
<span class="comment">;              :other :leaf}</span>
<span class="comment">;       :trigger-error :com.wsscode.pathom.core/reader-error}</span>
<span class="comment">;  :com.wsscode.pathom.core/errors {[:go :nest :trigger-error] &quot;class clojure.lang.ExceptionInfo: Error triggered - {:foo \&quot;bar\&quot;}&quot;</span>
<span class="comment">;                                   [:go :trigger-error] &quot;class clojure.lang.ExceptionInfo: Error triggered - {:foo \&quot;bar\&quot;}&quot;}}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, when an error occurs, the key <code>::p/errors</code> will be added to the returned map, containing the detailed error message indexed by the error path. You can customize how the error is exported in this map by setting the key <code>::p/process-error</code> in your environment:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.error-handling-process</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">computed</span>
  <span class="comment">; create a handle key that will trigger an error when called</span>
  {<span class="symbol">:trigger-error</span>
   (<span class="keyword">fn</span> [_]
     (<span class="keyword">throw</span> (ex-info <span class="string"><span class="delimiter">&quot;</span><span class="content">Error triggered</span><span class="delimiter">&quot;</span></span> {<span class="symbol">:foo</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span>})))})

<span class="comment">; a reader that just flows, until it reaches a leaf</span>
(<span class="keyword">defn</span> <span class="function">flow-reader</span> [{<span class="symbol">:keys</span> [query] <span class="symbol">:as</span> env}]
  (<span class="keyword">if</span> query
    (p/join env)
    <span class="symbol">:leaf</span>))

<span class="comment">; our error processing function</span>
(<span class="keyword">defn</span> <span class="function">process-error</span> [env err]
  <span class="comment">; if you use some error reporting service, this is a good place</span>
  <span class="comment">; to trigger a call to then, here you have the error and the full</span>
  <span class="comment">; environment of when it ocurred, so you might want to some extra</span>
  <span class="comment">; information like the query and the current path on it so you can</span>
  <span class="comment">; replay it for debugging</span>

  <span class="comment">; we are going to simply return the error message from the error</span>
  <span class="comment">; if you want to return the same thing as the default, use the</span>
  <span class="comment">; function (p/error-str err)</span>
  (<span class="keyword">.</span>getMessage err))

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [computed flow-reader]
                                         <span class="comment">; add the error processing to the environment</span>
                                         <span class="symbol">::p/process-error</span> process-error})
                          <span class="comment">; add the error handler plugin</span>
                          p/error-handler-plugin]}))

(parser {} [{<span class="symbol">:go</span> [<span class="symbol">:key</span> {<span class="symbol">:nest</span> [<span class="symbol">:trigger-error</span> <span class="symbol">:other</span>]}
                  <span class="symbol">:trigger-error</span>]}])
<span class="comment">; =&gt;</span>
<span class="comment">; {:go {:key :leaf</span>
<span class="comment">;       :nest {:trigger-error :com.wsscode.pathom.core/reader-error</span>
<span class="comment">;              :other :leaf}</span>
<span class="comment">;       :trigger-error :com.wsscode.pathom.core/reader-error}</span>
<span class="comment">;  :com.wsscode.pathom.core/errors {[:go :nest :trigger-error] &quot;Error triggered&quot;</span>
<span class="comment">;                                   [:go :trigger-error]       &quot;Error triggered&quot;}}</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_debugging_exceptions"><a class="anchor" href="#_debugging_exceptions"></a><a class="link" href="#_debugging_exceptions">5.4.1. Debugging exceptions</a></h4>
<div class="paragraph">
<p>By default Pathom error handler will just return a short error message about the exception,
but to debug you will want the stack trace. To view the stack trace you can use a custom
process-error, this is an example to do in Clojure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [computed flow-reader]
                                         <span class="comment">; add the error processing to the environment</span>
                                         <span class="symbol">::p/process-error</span>
                                         (<span class="keyword">fn</span> [_ err]
                                           <span class="comment">; print stack trace</span>
                                           (<span class="keyword">.</span>printStackTrace err)

                                           <span class="comment">; return error str</span>
                                           (p/error-str err)})
                          <span class="comment">; add the error handler plugin</span>
                          p/error-handler-plugin]}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In ClojureScript:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [computed flow-reader]
                                         <span class="comment">; add the error processing to the environment</span>
                                         <span class="symbol">::p/process-error</span>
                                         (<span class="keyword">fn</span> [_ err]
                                           <span class="comment">; print stack trace on console</span>
                                           (js/console.error err)

                                           <span class="comment">; return error str</span>
                                           (p/error-str err)})
                          <span class="comment">; add the error handler plugin</span>
                          p/error-handler-plugin]}))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_fail_fast"><a class="anchor" href="#_fail_fast"></a><a class="link" href="#_fail_fast">5.4.2. Fail fast</a></h4>
<div class="paragraph">
<p>Having each node being caught is great for the UI, but not so much for testing. During testing you probably prefer the parser to blow up as fast as possible so you don&#8217;t accumulate a bunch of errors that get impossible to read. Having to create a different parser to remove the <code>error-handler-plugin</code> can be annoying, so there is an option to solve that. Send the key <code>::p/fail-fast?</code> as true in the environment, and the try/catch will not be done, making it fail as soon as an exception fires, for example, using our previous parser:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(parser {<span class="symbol">::p/fail-fast?</span> <span class="predefined-constant">true</span>}
        [{<span class="symbol">:go</span> [<span class="symbol">:key</span> {<span class="symbol">:nest</span> [<span class="symbol">:trigger-error</span> <span class="symbol">:other</span>]}
               <span class="symbol">:trigger-error</span>]}])
<span class="comment">; =&gt; CompilerException clojure.lang.ExceptionInfo: Error triggered {:foo &quot;bar&quot;}, ...</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_raising_errors"><a class="anchor" href="#_raising_errors"></a><a class="link" href="#_raising_errors">5.4.3. Raising errors</a></h4>
<div class="paragraph">
<p>The default error output format (in a separated tree) is very convenient for direct API
calls, because they leave a clean output on the data part. But if you want to expose those
errors on the UI, pulling then out of the separated tree can be a bit of a pain. To help
with that there is a <code>p/raise-errors</code> helper, this will lift the errors so they are present
at the same level of the error entry. Let&#8217;s take our last error output example and process
it with <code>p/raise-errors</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(p/raise-errors {<span class="symbol">:go</span> {<span class="symbol">:key</span> <span class="symbol">:leaf</span>
                      <span class="symbol">:nest</span> {<span class="symbol">:trigger-error</span> <span class="symbol">:com.wsscode.pathom.core/reader-error</span>
                             <span class="symbol">:other</span> <span class="symbol">:leaf</span>}
                      <span class="symbol">:trigger-error</span> <span class="symbol">:com.wsscode.pathom.core/reader-error</span>}
                 <span class="symbol">:com.wsscode.pathom.core/errors</span> {[<span class="symbol">:go</span> <span class="symbol">:nest</span> <span class="symbol">:trigger-error</span>] <span class="string"><span class="delimiter">&quot;</span><span class="content">Error triggered</span><span class="delimiter">&quot;</span></span>
                                                  [<span class="symbol">:go</span> <span class="symbol">:trigger-error</span>] <span class="string"><span class="delimiter">&quot;</span><span class="content">Error triggered</span><span class="delimiter">&quot;</span></span>}})

<span class="comment">; outputs:</span>

{<span class="symbol">:go</span> {<span class="symbol">:key</span> <span class="symbol">:leaf</span>
      <span class="symbol">:nest</span> {<span class="symbol">:trigger-error</span> <span class="symbol">:com.wsscode.pathom.core/reader-error</span>
             <span class="symbol">:other</span> <span class="symbol">:leaf</span>
             <span class="symbol">:com.wsscode.pathom.core/errors</span> {<span class="symbol">:trigger-error</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Error triggered</span><span class="delimiter">&quot;</span></span>}}
      <span class="symbol">:trigger-error</span> <span class="symbol">:com.wsscode.pathom.core/reader-error</span>
      <span class="symbol">:com.wsscode.pathom.core/errors</span> {<span class="symbol">:trigger-error</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Error triggered</span><span class="delimiter">&quot;</span></span>}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that we don&#8217;t have the root <code>::p/errors</code> anymore, instead it is placed at the
same level of the error attribute. So the path <code>[::p/errors [:go :nest :trigger-error]]</code>
turns into <code>[:go :nest ::p/errors :trigger-error]</code>. This makes very easy to pull the
error on the client-side.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dispatch-helpers"><a class="anchor" href="#dispatch-helpers"></a><a class="link" href="#dispatch-helpers">5.5. Dispatch helpers</a></h3>
<div class="paragraph">
<p>Using multi-methods is a good way to make open readers, <code>pathom</code> provides helpers for two common dispatch strategies:
<code>key-dispatch</code> and <code>entity-dispatch</code>. Here is a pattern that I often use on parsers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.dispatch-helpers</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">cities</span>
  {<span class="string"><span class="delimiter">&quot;</span><span class="content">Recife</span><span class="delimiter">&quot;</span></span>    {<span class="symbol">:city/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Recife</span><span class="delimiter">&quot;</span></span> <span class="symbol">:city/country</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Brazil</span><span class="delimiter">&quot;</span></span>}
   <span class="string"><span class="delimiter">&quot;</span><span class="content">São Paulo</span><span class="delimiter">&quot;</span></span> {<span class="symbol">:city/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">São Paulo</span><span class="delimiter">&quot;</span></span> <span class="symbol">:city/country</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Brazil</span><span class="delimiter">&quot;</span></span>}})

(<span class="keyword">def</span> <span class="function">city-&gt;neighbors</span>
  {<span class="string"><span class="delimiter">&quot;</span><span class="content">Recife</span><span class="delimiter">&quot;</span></span> [{<span class="symbol">:neighbor/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Boa Viagem</span><span class="delimiter">&quot;</span></span>}
             {<span class="symbol">:neighbor/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Piedade</span><span class="delimiter">&quot;</span></span>}
             {<span class="symbol">:neighbor/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Casa Amarela</span><span class="delimiter">&quot;</span></span>}]})

<span class="comment">; this will dispatch according to the ast dispatch-key</span>
(<span class="keyword">defmulti</span> <span class="function">computed</span> p/key-dispatch)

<span class="comment">; use virtual attributes to handle data not present on the maps, like computed attributes, relationships, and globals</span>
(<span class="keyword">defmethod</span> <span class="function">computed</span> <span class="symbol">:city/neighbors</span> [env]
  (<span class="keyword">let</span> [<span class="keyword">name</span> (p/entity-attr! env <span class="symbol">:city/name</span>)]
    (p/join-seq env (city-&gt;neighbors <span class="keyword">name</span>))))

<span class="comment">; an example of global, same as before but without any dependency on the entity</span>
(<span class="keyword">defmethod</span> <span class="function">computed</span> <span class="symbol">:city/all</span> [env]
  (p/join-seq env (<span class="keyword">vals</span> cities)))

<span class="comment">; remember to return ::p/continue by default so non-handled cases can flow</span>
(<span class="keyword">defmethod</span> <span class="function">computed</span> <span class="symbol">:default</span> [_] <span class="symbol">::p/continue</span>)

<span class="comment">; just to make easy to re-use, our base entity reader consists of a map reader + virtual attributes</span>
(<span class="keyword">def</span> <span class="function">entity-reader</span> [p/map-reader computed])

<span class="comment">; dispatch for entity keys, eg: [:user/by-id 123]</span>
(<span class="keyword">defmulti</span> <span class="function">entity-lookup</span> p/entity-dispatch)

(<span class="keyword">defmethod</span> <span class="function">entity-lookup</span> <span class="symbol">:city/by-name</span> [env]
  <span class="comment">; the ident-value helper extracts the value part from the ident, as &quot;Recife&quot; in [:city/by-name &quot;Recife&quot;]</span>
  (<span class="keyword">let</span> [city (<span class="keyword">get</span> cities (p/ident-value env))]
    (p/join city env)))

(<span class="keyword">defmethod</span> <span class="function">entity-lookup</span> <span class="symbol">:default</span> [_] <span class="symbol">::p/continue</span>)

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [p/map-reader computed entity-lookup]})]}))

(parser {} [{<span class="symbol">:city/all</span> [<span class="symbol">:city/name</span>]}
            {[<span class="symbol">:city/by-name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Recife</span><span class="delimiter">&quot;</span></span>] [<span class="symbol">:city/neighbors</span>]}])
<span class="comment">; =&gt;</span>
<span class="comment">;{:city/all [#:city{:name &quot;Recife&quot;} #:city{:name &quot;São Paulo&quot;}]</span>
<span class="comment">; [:city/by-name &quot;Recife&quot;] #:city{:neighbors [#:neighbor{:name &quot;Boa Viagem&quot;}</span>
<span class="comment">;                                             #:neighbor{:name &quot;Piedade&quot;}</span>
<span class="comment">;                                             #:neighbor{:name &quot;Casa Amarela&quot;}]}}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mutations"><a class="anchor" href="#_mutations"></a><a class="link" href="#_mutations">5.6. Mutations</a></h3>
<div class="paragraph">
<p>To handle mutations, you can send the <code>:mutate</code> param to the parser.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.mutation</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [fulcro.client.primitives <span class="symbol">:as</span> fp]))

(<span class="keyword">defmulti</span> <span class="function">my-mutate</span> fp/dispatch)

(<span class="keyword">defmethod</span> <span class="function">my-mutate</span> `do-operation [{<span class="symbol">:keys</span> [state]} _ params]
  (<span class="keyword">swap!</span> state update <span class="symbol">:history</span> <span class="keyword">conj</span> {<span class="symbol">:op</span> <span class="symbol">:operation</span> <span class="symbol">:params</span> params}))

(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {<span class="symbol">:mutate</span> my-mutate}))

(<span class="keyword">comment</span>
  (<span class="keyword">let</span> [state (<span class="keyword">atom</span> {<span class="symbol">:history</span> []})]
    (parser {<span class="symbol">:state</span> state} [`(do-operation {<span class="symbol">:foo</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span>})
                            `(do-operation {<span class="symbol">:buz</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span>})])
    @state)
  <span class="comment">; =&gt; {:history [{:op :operation, :params {:foo &quot;bar&quot;}}</span>
  <span class="comment">;               {:op :operation, :params {:buz &quot;baz&quot;}}]}</span>
  )</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="RequestCaching"><a class="anchor" href="#RequestCaching"></a><a class="link" href="#RequestCaching">5.7. Request Caching</a></h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Before 2.2.0 you had to include the <code>p/request-cache</code> plugin into your plugin list, since 2.2.0 this is no longer nescessary,
it&#8217;s always available
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As your queries grow, there are more and more optimizations that you can do avoid unnecessary IO or heavy computations. Here we are going to talk about a <code>request cache</code>, which is a fancy name for an atom that is initialized on every query and stays on the environment so you can share the cache across nodes. Let&#8217;s see how we can use that to speed up our query processing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.request-cache</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">defn</span> <span class="function">my-expensive-operation</span> [env]
  <span class="comment">; the cache key can be anything; if we were had an extra</span>
  <span class="comment">; variable here, like some id, a good cache key would be</span>
  <span class="comment">; like: [::my-expensive-operation id]</span>
  (p/cached env <span class="symbol">:my-key</span>
    <span class="comment">; we are going to send an atom with an int so that we can count</span>
    <span class="comment">; how many times this was called</span>
    (<span class="keyword">let</span> [counter (<span class="symbol">:counter</span> env)]
      <span class="comment">; a secondary sign if cache is working, let's make a delay</span>
      (Thread/sleep <span class="integer">1000</span>)
      <span class="comment">; increment and return</span>
      (<span class="keyword">swap!</span> counter <span class="keyword">inc</span>))))

(<span class="keyword">def</span> <span class="function">computed</span>
  {<span class="symbol">:cached</span> my-expensive-operation})

<span class="comment">; a reader that just flows, until it reaches a leaf</span>
(<span class="keyword">defn</span> <span class="function">flow-reader</span> [{<span class="symbol">:keys</span> [query] <span class="symbol">:as</span> env}]
  (<span class="keyword">if</span> query
    (p/join env)
    <span class="symbol">:leaf</span>))

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [computed
                                                     flow-reader]})]}))

(<span class="keyword">time</span>
  (parser {<span class="symbol">:counter</span> (<span class="keyword">atom</span> <span class="integer">0</span>)}
          [<span class="symbol">:x</span> <span class="symbol">:y</span> <span class="symbol">:cached</span>
           {<span class="symbol">:z</span> [<span class="symbol">:foo</span> {<span class="symbol">:bar</span> [<span class="symbol">:cached</span>]} <span class="symbol">:cached</span>]}]))
<span class="comment">; &quot;Elapsed time: 1006.760165 msecs&quot;</span>
<span class="comment">; =&gt;</span>
<span class="comment">; {:x      :leaf</span>
<span class="comment">;  :y      :leaf</span>
<span class="comment">;  :cached 1</span>
<span class="comment">;  :z      {:foo    :leaf</span>
<span class="comment">;           :bar    {:cached 1}</span>
<span class="comment">;           :cached 1}}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember this cache is <strong>per request</strong>, so after a full query gets finished, the atom is discarded. If you want to make a cache that&#8217;s more durable (that retains information across requests), check the [[Plugins|Plugins]] documentation for more information on how to do that.</p>
</div>
</div>
<div class="sect2">
<h3 id="_plugins"><a class="anchor" href="#_plugins"></a><a class="link" href="#_plugins">5.8. Plugins</a></h3>
<div class="paragraph">
<p>Pathom allows a parser to have a collection of plugins that modify its behavior. Plugins is a top-level option when creating the parser, and the value is a vector of plugins:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {<span class="symbol">::p/plugins</span> [<span class="keyword">..</span><span class="keyword">.</span>]}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this section we&#8217;ll be using a few plugins to make our lives easier.</p>
</div>
<div class="paragraph">
<p>Plugins set code that wraps some of pathom operations, a plugin is a map where you bind
keys from event names to functions. They work on <code>wrap</code> fashion, kind like <code>ring</code> wrappers.
Here is what a plugin looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.plugin-example</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">my-plugin</span>
  <span class="comment">; the ::p/wrap-parser entry point wraps the entire parser,</span>
  <span class="comment">; this means it wraps the operation that runs once on each</span>
  <span class="comment">; query that runs with the parser</span>
  {<span class="symbol">::p/wrap-parser</span>
   (<span class="keyword">fn</span> [parser]
     <span class="comment">; here you can initialize stuff that runs only once per</span>
     <span class="comment">; parser, like a durable cache across requests</span>
     (<span class="keyword">fn</span> [env tx]
       <span class="comment">; here you could initialize per-request items, things</span>
       <span class="comment">; that needs to be set up once per query as we do on</span>
       <span class="comment">; request cache, or the error atom to accumulate errors</span>

       <span class="comment">; in this case, we are doing nothing, just calling the</span>
       <span class="comment">; previous parser, a pass-through wrapper if you may</span>
       (parser env tx)))

   <span class="comment">; this wraps the read function, meaning it will run once for</span>
   <span class="comment">; each recursive parser call that happens during your query</span>
   <span class="symbol">::p/wrap-read</span>
   (<span class="keyword">fn</span> [reader]
     (<span class="keyword">fn</span> [env]
       <span class="comment">; here you can wrap the parse read, in pathom we use this</span>
       <span class="comment">; on the error handler to do the try/catch per node, also</span>
       <span class="comment">; the profiler use this point to calculate the time spent</span>
       <span class="comment">; on a given node</span>

       <span class="comment">; this is also a good point to inject custom read keys if</span>
       <span class="comment">; you need to, the profile plugin, for example, can capture</span>
       <span class="comment">; the key ::p.profile/profile and export the current profile</span>
       <span class="comment">; information</span>
       (reader env)))})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The plugin engine replaces the old <code>process-reader</code> in a much more powerful way. If you want to check a real example look for the source for the built-in plugins, they are quite small and yet powerful tools (grep for <code>-plugin</code> on the repository to find all of them).</p>
</div>
<div class="sect3">
<h4 id="_the_environment_plugin"><a class="anchor" href="#_the_environment_plugin"></a><a class="link" href="#_the_environment_plugin">5.8.1. The Environment Plugin</a></h4>
<div class="paragraph">
<p>Typically the parsing environment will need to include things you create and inject every time you parse a query (e.g. a
database connection) and some parser-related things (e.g. the reader) that might be the same all the time.</p>
</div>
<div class="paragraph">
<p>In the earlier example we created the parser and then <strong>explicitly</strong> supplied a reader to the environment every time we
called it. In cases where there are specific things that you&#8217;d always like included in the environment we can instead
use the plugin system to pre-set them for every parse.</p>
</div>
<div class="paragraph">
<p>So, in our prior example we had:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>and every call to the parser needed an explicit reader: <code>(parser {::p/reader computed} [:hello])</code></p>
</div>
<div class="paragraph">
<p>The <code>p/env-plugin</code> is a parser plugin that automatically merges a map of configuration into the parsing environment every time the parser is called. Thus, our earlier example can be converted to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> computed})]}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>and now each call to the parser needs nothing in the env on each invocation: <code>(parser {} [:hello])</code>.</p>
</div>
<div class="paragraph">
<p>Providing an environment is such a common operation that there is a shortcut to set it up:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {<span class="symbol">::p/env</span> {<span class="symbol">::p/reader</span> computed}}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>::p/env</code> option to the parser tells it to install the <code>env-plugin</code> with the given configuration.</p>
</div>
</div>
<div class="sect3">
<h4 id="_example_shard_switch"><a class="anchor" href="#_example_shard_switch"></a><a class="link" href="#_example_shard_switch">5.8.2. Example: Shard switch</a></h4>
<div class="paragraph">
<p>For a more practical example, let&#8217;s say we are routing in a micro-service architecture
and our parser needs to be shard-aware. Let&#8217;s write a plugin that anytime it sees a <code>:shard</code>
param on a query; and it will update the <code>:shard</code> attribute on the environment and send
it down, providing that shard information for any node downstream.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.plugin-shard</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

<span class="comment">; a reader that just flows, until it reaches a leaf</span>
(<span class="keyword">defn</span> <span class="function">flow-reader</span> [{<span class="symbol">:keys</span> [query] <span class="symbol">:as</span> env}]
  (<span class="keyword">if</span> query
    (p/join env)
    <span class="symbol">:leaf</span>))

(<span class="keyword">def</span> <span class="function">shard-reader</span>
  <span class="comment">; Clojure neat tricks, let's just fetch the shard</span>
  <span class="comment">; from the environment when :current-shard is asked</span>
  {<span class="symbol">:current-shard</span> <span class="symbol">:shard</span>})

(<span class="keyword">def</span> <span class="function">shard-plugin</span>
  {<span class="symbol">::p/wrap-read</span>
   (<span class="keyword">fn</span> [reader]
     (<span class="keyword">fn</span> [env]
       <span class="comment">; try to get a new shard from the query params</span>
       (<span class="keyword">let</span> [new-shard (<span class="keyword">get-in</span> env [<span class="symbol">:ast</span> <span class="symbol">:params</span> <span class="symbol">:shard</span>])]
         (reader (cond-&gt; env new-shard (<span class="keyword">assoc</span> <span class="symbol">:shard</span> new-shard))))))})

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [shard-reader flow-reader]})
                          <span class="comment">; use our shard plugin</span>
                          shard-plugin]}))

(parser {<span class="symbol">:shard</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">global</span><span class="delimiter">&quot;</span></span>}
        '[<span class="symbol">:a</span> <span class="symbol">:b</span> <span class="symbol">:current-shard</span>
          {(<span class="symbol">:go-s1</span> {<span class="symbol">:shard</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">s1</span><span class="delimiter">&quot;</span></span>})
           <span class="comment">; notice it flows down</span>
           [<span class="symbol">:x</span> <span class="symbol">:current-shard</span> {<span class="symbol">:y</span> [<span class="symbol">:current-shard</span>]}]}
          <span class="symbol">:c</span>
          {(<span class="symbol">:go-s2</span> {<span class="symbol">:shard</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">s2</span><span class="delimiter">&quot;</span></span>})
           [<span class="symbol">:current-shard</span>
            <span class="comment">; we can override at any point</span>
            {(<span class="symbol">:now-s3</span> {<span class="symbol">:shard</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">s3</span><span class="delimiter">&quot;</span></span>})
             [<span class="symbol">:current-shard</span>]}]}])
<span class="comment">; =&gt;</span>
<span class="comment">; {:a             :leaf</span>
<span class="comment">;  :b             :leaf</span>
<span class="comment">;  :current-shard &quot;global&quot;</span>
<span class="comment">;  :go-s1         {:x :leaf :current-shard &quot;s1&quot; :y {:current-shard &quot;s1&quot;}}</span>
<span class="comment">;  :c             :leaf</span>
<span class="comment">;  :go-s2         {:current-shard &quot;s2&quot; :now-s3 {:current-shard &quot;s3&quot;}}}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_testing_todo"><a class="anchor" href="#_testing_todo"></a><a class="link" href="#_testing_todo">5.9. Testing #TODO</a></h3>

</div>
<div class="sect2">
<h3 id="_placeholders"><a class="anchor" href="#_placeholders"></a><a class="link" href="#_placeholders">5.10. Placeholders</a></h3>
<div class="paragraph">
<p>Flattening your data makes more convient for the use because it increases connection
of the data, facilitating the access. But sometimes when developing using interfaces the
UI will require some structuring. For example, let&#8217;s say you have a user that participates
in a group, so you can access <code>:user/id</code>, <code>:user/name</code>, <code>:group/id</code> and <code>:group/name</code>.</p>
</div>
<div class="paragraph">
<p>Then we a component to render the group header.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(fp/defsc GroupHeaderView [_ _]
  {<span class="symbol">:ident</span> [<span class="symbol">:group/id</span>]
   <span class="symbol">:query</span> [<span class="symbol">:group/id</span> <span class="symbol">:group/name</span>]})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now it&#8217;s time to create a component for the user, but we want to use the <code>GroupHeaderView</code>
to display the user group header. In Fulcro this means from the user we need to make
a join to query for the <code>GroupHeaderView</code>, something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(fp/defsc UserImageView [_ _]
  {<span class="symbol">:ident</span> [<span class="symbol">:user/id</span> <span class="symbol">:user/id</span>]
   <span class="symbol">:query</span> [<span class="symbol">:user/id</span> <span class="symbol">:user/name</span>
           {??? (fp/get-query GroupView)}]})</code></pre>
</div>
</div>
<div class="paragraph">
<p>To fill in the <code>???</code>, he trick is to make some namespaces special, they make an edge on
a graph that keeps the same context as the previous node.
This way we can convienetly reshape the data to give it more structure.</p>
</div>
<div class="paragraph">
<p>If you look at the parser default configuration, we set the key <code>::p/placeholder-prefixes #{"&gt;"}</code> in the
environment. This set will be used by the <code>p/placeholder-env-reader</code> and make a join using the given
key while maintaining the context. Plugin and reader implementors can take advantage of
this available information (placeholder namespaces) so the can handle accordinly.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tracing"><a class="anchor" href="#_tracing"></a><a class="link" href="#_tracing">5.11. Tracing</a></h3>
<div class="paragraph">
<p>Pathom <code>2.2.0</code> provides a replacement for the old profiler. The old profiler works
by wrapping the calls to the Pathom reader and measuring the time around that, this is
limiting because then you only have one measure per attribute.</p>
</div>
<div class="paragraph">
<p>The new tracer works as a event stream, you can inject log events at any time, events
might have duration or not (even for events with start and finish, they are recorded as
separated events and are combined in a post-processing operation).</p>
</div>
<div class="paragraph">
<p>This enables detailed logs to understand what happened during the processing of a query, and
pathom core already has some system level tracing logs that go automatically, and you
can add yours.</p>
</div>
<div class="paragraph">
<p>To enable the tracing you must add the plugin <code>p/trace-plugin</code> to your parser plugins vector.</p>
</div>
<div class="sect3">
<h4 id="_logging_custom_events"><a class="anchor" href="#_logging_custom_events"></a><a class="link" href="#_logging_custom_events">5.11.1. Logging custom events</a></h4>
<div class="paragraph">
<p>To log custom events you use the function <code>com.wsscode.pathom.trace/trace</code>.</p>
</div>
<div class="paragraph">
<p>Here is an example parser with some interesting tracing details, run the query to have
a look:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.tracing.demo</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
            [com.wsscode.pathom.trace <span class="symbol">:as</span> pt]
            [clojure.core.async <span class="symbol">:as</span> async]
            [com.wsscode.common.async-cljs <span class="symbol">:refer</span> [go-catch &lt;?]]))

(pc/defresolver slow-root [env _]
  {<span class="symbol">::pc/output</span> [<span class="symbol">::slow-root</span>]}
  (go-catch
    <span class="comment">; here we use the tracing macro to compute the time for the timeout</span>
    (pt/tracing env {<span class="symbol">::pt/event</span> <span class="symbol">::my-event</span>
                     <span class="symbol">::pt/style</span> {<span class="symbol">:fill</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">rgba(255, 255, 0, 0.5)</span><span class="delimiter">&quot;</span></span>}}
      (&lt;? (async/timeout <span class="integer">200</span>)))
    {<span class="symbol">::slow-root</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>}))

(pc/defresolver slow-root-dep [env _]
  {<span class="symbol">::pc/input</span> #{<span class="symbol">::slow-root</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">::root-dep</span>]}
  (go-catch
    (pt/tracing env {<span class="symbol">::pt/event</span> <span class="symbol">::my-event</span>}
      (&lt;? (async/timeout <span class="integer">200</span>)))
    {<span class="symbol">::root-dep</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">nah</span><span class="delimiter">&quot;</span></span>}))

(pc/defresolver error-root-dep [env _]
  {<span class="symbol">::pc/input</span> #{<span class="symbol">::slow-root</span>}
   <span class="symbol">::pc/output</span> [<span class="symbol">::root-dep-err</span>]}
  (go-catch
    (pt/tracing env {<span class="symbol">::pt/event</span> <span class="symbol">::my-event</span>
                     <span class="symbol">::data</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Error message</span><span class="delimiter">&quot;</span></span>
                     <span class="symbol">::pt/style</span> {<span class="symbol">:fill</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">rgba(255, 0, 0, 0.5)</span><span class="delimiter">&quot;</span></span>}}
      (&lt;? (async/timeout <span class="integer">200</span>)))
    (<span class="keyword">throw</span> (ex-info <span class="string"><span class="delimiter">&quot;</span><span class="content">Meh</span><span class="delimiter">&quot;</span></span> {}))))

(<span class="keyword">def</span> <span class="function">app-registry</span> [slow-root slow-root-dep error-root-dep])

<span class="comment">; to display the tracing with the results you must register the event type</span>
(<span class="keyword">defmethod</span> <span class="function">pt/trace-tree-collect</span> <span class="symbol">::my-event</span> [x row]
  (<span class="keyword">-&gt;</span> row
      <span class="comment">; the sequence at the end is a list with the keys to display in the trace when</span>
      <span class="comment">; user mouses over the event</span>
      (pt/tree-assoc-detail x [<span class="symbol">::data</span>])))

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parallel-parser
    {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span>               [p/map-reader
                                            pc/parallel-reader
                                            pc/open-ident-reader
                                            p/env-placeholder-reader]
                  <span class="symbol">::p/placeholder-prefixes</span> #{<span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;</span><span class="delimiter">&quot;</span></span>}}
     <span class="symbol">::p/mutate</span>  pc/mutate-async
     <span class="symbol">::p/plugins</span> [(pc/connect-plugin {<span class="symbol">::pc/register</span> app-registry})
                  p/error-handler-plugin
                  p/request-cache-plugin
                  p/trace-plugin]}))</code></pre>
</div>
</div>
<div x-app="interactive-parser" data-parser="tracing.demo1" class="loader">
[:com.wsscode.pathom.book.tracing.demo/root-dep
 :com.wsscode.pathom.book.tracing.demo/root-dep-err]
</div>
<div class="space"></div>
</div>
</div>
<div class="sect2">
<h3 id="_profiling_deprecated_prefer_the_tracing"><a class="anchor" href="#_profiling_deprecated_prefer_the_tracing"></a><a class="link" href="#_profiling_deprecated_prefer_the_tracing">5.12. Profiling [DEPRECATED, prefer the tracing]</a></h3>
<div class="paragraph">
<p>It&#8217;s good to know how your queries are performing, and breaking it down by nodes is an excellent level to reason about how your queries are doing. Pathom provides a plugin to make this measurement easy to do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.profile</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [com.wsscode.pathom.profile <span class="symbol">:as</span> p.profile]))

(<span class="keyword">def</span> <span class="function">computed</span>
  <span class="comment">; to demo delays, this property will take some time</span>
  {<span class="symbol">:expensive</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [query] <span class="symbol">:as</span> env}]
                (Thread/sleep <span class="integer">300</span>)
                (<span class="keyword">if</span> query
                  (p/join env)
                  <span class="symbol">:done</span>))})

(<span class="keyword">defn</span> <span class="function">flow-reader</span> [{<span class="symbol">:keys</span> [query] <span class="symbol">:as</span> env}]
  (<span class="keyword">if</span> query
    (p/join env)
    <span class="symbol">:leaf</span>))

<span class="comment">; starting the parser as usual</span>
(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [computed flow-reader]})
                          <span class="comment">; include the profile plugin</span>
                          p.profile/profile-plugin]}))

(parser {}
        <span class="comment">; run the things</span>
        [<span class="symbol">:a</span> <span class="symbol">:b</span> {<span class="symbol">:expensive</span> [<span class="symbol">:c</span> <span class="symbol">:d</span> {<span class="symbol">:e</span> [<span class="symbol">:expensive</span>]}]}
         <span class="comment">; profile plugin provide this key, when you ask for it you get the</span>
         <span class="comment">; information, be sure to request this as the last item on your query</span>
         <span class="symbol">::p.profile/profile</span>])
<span class="comment">; =&gt;</span>
<span class="comment">; {:a                  :leaf</span>
<span class="comment">;  :b                  :leaf</span>
<span class="comment">;  :expensive          {:c :leaf</span>
<span class="comment">;                       :d :leaf</span>
<span class="comment">;                       :e {:expensive :done}}</span>
<span class="comment">;  ::p.profile/profile {:a         0</span>
<span class="comment">;                       :b         0</span>
<span class="comment">;                       :expensive {:c               1</span>
<span class="comment">;                                   :d               0</span>
<span class="comment">;                                   :e               {:expensive 304</span>
<span class="comment">;                                                     ::p.profile/self 304}</span>
<span class="comment">;                                   ::p.profile/self 611}}}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Looking at the profile results, you see the query values, and at the edges is the <code>ms</code> time taken to process that node. When the node has children, a <code>::p.profile/self</code> indicates the time for the node itself (including children).</p>
</div>
<div class="paragraph">
<p>If you like to print a flame-graph of this output, you can use some d3 libraries on the web, I recommend the [d3 flame graph from spierman](<a href="https://github.com/spiermar/d3-flame-graph" class="bare">https://github.com/spiermar/d3-flame-graph</a>). Pathom has a function to convert the profile data to the format accepted by that library:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">-&gt;</span> (parser {}
            <span class="comment">; let's add more things this time</span>
            [<span class="symbol">:a</span> {<span class="symbol">:b</span> [<span class="symbol">:g</span> {<span class="symbol">:expensive</span> [<span class="symbol">:f</span>]}]}
             {<span class="symbol">:expensive</span> [<span class="symbol">:c</span> <span class="symbol">:d</span> {<span class="symbol">:e</span> [<span class="symbol">:expensive</span>]}]}
             <span class="symbol">::p.profile/profile</span>])
    <span class="comment">; get the profile</span>
    <span class="symbol">::p.profile/profile</span>
    <span class="comment">; generate the name/value/children format</span>
    p.profile/profile-&gt;nvc)
<span class="comment">; =&gt;</span>
<span class="comment">; {:name     &quot;Root&quot;</span>
<span class="comment">;  :value    910</span>
<span class="comment">;  :children [{:name &quot;:a&quot; :value 0}</span>
<span class="comment">;             {:name     &quot;:b&quot;</span>
<span class="comment">;              :value    305</span>
<span class="comment">;              :children [{:name &quot;:g&quot; :value 0} {:name &quot;:expensive&quot; :value 304 :children [{:name &quot;:f&quot; :value 1}]}]}</span>
<span class="comment">;             {:name     &quot;:expensive&quot;</span>
<span class="comment">;              :value    605</span>
<span class="comment">;              :children [{:name &quot;:c&quot; :value 0}</span>
<span class="comment">;                         {:name &quot;:d&quot; :value 1}</span>
<span class="comment">;                         {:name &quot;:e&quot; :value 301 :children [{:name &quot;:expensive&quot; :value 300}]}]}]}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And then use that data to generate the flame graph:</p>
</div>
<div class="paragraph">
<p>![Profile demo](<a href="https://github.com/wilkerlucio/pathom/blob/master/doc-examples/images/profile-flame-demo.png" class="bare">https://github.com/wilkerlucio/pathom/blob/master/doc-examples/images/profile-flame-demo.png</a>)</p>
</div>
</div>
<div class="sect2">
<h3 id="_path_tracking"><a class="anchor" href="#_path_tracking"></a><a class="link" href="#_path_tracking">5.13. Path tracking</a></h3>
<div class="paragraph">
<p>As you go deep in your parser <code>pathom</code> track record of the current path taken, it&#8217;s available at <code>::p/path</code> at any time. It&#8217;s a vector containing the current path from the root, the current main use for it is regarding error reporting and profiling.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.path-tracking</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">where-i-am-reader</span>
  {<span class="symbol">:where-am-i</span> (<span class="keyword">fn</span> [{<span class="symbol">::p/keys</span> [path]}] path)})

<span class="comment">; a reader that just flows, until it reaches a leaf</span>
(<span class="keyword">defn</span> <span class="function">flow-reader</span> [{<span class="symbol">:keys</span> [query] <span class="symbol">:as</span> env}]
  (<span class="keyword">if</span> query
    (p/join env)
    <span class="symbol">:leaf</span>))

(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [where-i-am-reader
                                                               flow-reader]})]}))

(parser {} [{<span class="symbol">:hello</span> [<span class="symbol">:some</span> {<span class="symbol">:friend</span> [<span class="symbol">:place</span> <span class="symbol">:where-am-i</span>]}]}])
<span class="comment">;=&gt;</span>
<span class="comment">;{:hello {:some   :leaf</span>
<span class="comment">;         :friend {:place      :leaf</span>
<span class="comment">;                  :where-am-i [:hello :friend :where-am-i]}}}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="AsyncParsing"><a class="anchor" href="#AsyncParsing"></a><a class="link" href="#AsyncParsing">5.14. Async parsing</a></h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Nowadays the parallel parser is the recommended one to use because of the query
strategy, but all the concepts presented here for async parser also applies to the
parallel parser, which is async.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you want to write parsers to run in Javascript environments, then async operations are the norm. The async
parser is a version of the parser were you can return core async channels from the readers instead of raw
values. This allows for the creation of parsers that do network requests or any other async operation.
The async parser is still semantically a <strong>serial</strong> parser, and it will have the same flow characteristics
of the regular parser (the order or resolution is preserved).</p>
</div>
<div class="paragraph">
<p>To write an async parser we use the <code>p/async-parser</code> function. Here is an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.async.intro</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [cljs.core.async <span class="symbol">:as</span> async <span class="symbol">:refer</span> [go &lt;!]]
            [com.wsscode.pathom.profile <span class="symbol">:as</span> pp]))

(<span class="keyword">defn</span> <span class="function">sleep</span> [n]
  (<span class="keyword">let</span> [c (async/chan)]
    (js/setTimeout #(async/put! c <span class="symbol">::done</span>) n)
    c))

(<span class="keyword">def</span> <span class="function">reader</span>
  {<span class="symbol">:async-info</span>
   (<span class="keyword">fn</span> [_]
     (go
       (&lt;! (sleep (<span class="keyword">+</span> <span class="integer">100</span> (<span class="keyword">rand-int</span> <span class="integer">1000</span>))))
       <span class="string"><span class="delimiter">&quot;</span><span class="content">From async</span><span class="delimiter">&quot;</span></span>))

   <span class="symbol">:foo</span>
   (<span class="keyword">fn</span> [_]
     <span class="string"><span class="delimiter">&quot;</span><span class="content">Regular</span><span class="delimiter">&quot;</span></span>)})

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/async-parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> reader})
                                pp/profile-plugin]}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Try the example:</p>
</div>
<div x-app="interactive-parser" data-parser="async.intro" class="loader">
[:foo :async-info]
</div>
<div class="space"></div>
<div class="paragraph">
<p>The core plugins work normally with the async parser, so error and profiling will work as expected.</p>
</div>
<div class="sect3">
<h4 id="_error_propagation"><a class="anchor" href="#_error_propagation"></a><a class="link" href="#_error_propagation">5.14.1. Error propagation</a></h4>
<div class="paragraph">
<p>When an exception occurs inside a core async channel the error is triggered as part of the channel exception handler.
That doesn&#8217;t compose very well, and for the parser needs it&#8217;s better if we have something more like the async/await
pattern used on JS environments. Pathom provides some macros to help making this a simple thing, instead of using
<code>go</code> and <code>&lt;!</code>, use the <code>go-catch</code> and <code>&lt;?</code> macros, as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.async.error-propagation</span>
  (<span class="symbol">:require</span> [cljs.core.async <span class="symbol">:as</span> async]
            [com.wsscode.common.async-cljs <span class="symbol">:refer</span> [go-catch &lt;?]]
            [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [com.wsscode.pathom.profile <span class="symbol">:as</span> pp]))

(<span class="keyword">defn</span> <span class="function">sleep</span> [n]
  (<span class="keyword">let</span> [c (async/chan)]
    (js/setTimeout #(async/put! c <span class="symbol">::done</span>) n)
    c))

(<span class="keyword">def</span> <span class="function">reader</span>
  {<span class="symbol">:async-info</span>
   (<span class="keyword">fn</span> [_]
     (go-catch
       (&lt;? (sleep (<span class="keyword">+</span> <span class="integer">100</span> (<span class="keyword">rand-int</span> <span class="integer">1000</span>))))
       <span class="string"><span class="delimiter">&quot;</span><span class="content">From async</span><span class="delimiter">&quot;</span></span>))

   <span class="symbol">:async-error</span>
   (<span class="keyword">fn</span> [_]
     <span class="comment">; go catch will catch any exception and return then as the channel value</span>
     (go-catch
       <span class="comment">; &lt;? macro will re-throw any exception that get read from the channel</span>
       (&lt;? (sleep (<span class="keyword">+</span> <span class="integer">100</span> (<span class="keyword">rand-int</span> <span class="integer">1000</span>))))
       (<span class="keyword">throw</span> (ex-info <span class="string"><span class="delimiter">&quot;</span><span class="content">Error!!</span><span class="delimiter">&quot;</span></span> {}))))

   <span class="symbol">:foo</span>
   (<span class="keyword">fn</span> [_]
     <span class="string"><span class="delimiter">&quot;</span><span class="content">Regular</span><span class="delimiter">&quot;</span></span>)})

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/async-parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> reader})
                                p/error-handler-plugin
                                pp/profile-plugin]}))</code></pre>
</div>
</div>
<div x-app="interactive-parser" data-parser="async.error-propagation" class="loader">
[:foo :async-info :async-error :com.wsscode.pathom.profile/profile]
</div>
<div class="space"></div>
<div class="paragraph">
<p>Use <code>com.wsscode.common.async-clj</code> for Clojure and <code>com.wsscode.common.async-cljs</code> for ClojureScript. If you writing a
cljc file, use the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[<span class="error">#</span>?(<span class="symbol">:clj</span>  com.wsscode.common.async-clj
    <span class="symbol">:cljs</span> com.wsscode.common.async-cljs)
 <span class="symbol">:refer</span> [go-catch &lt;?]]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_js_promises"><a class="anchor" href="#_js_promises"></a><a class="link" href="#_js_promises">5.14.2. JS Promises</a></h4>
<div class="paragraph">
<p>In JS world most of the current async responses comes as promises, you can use the <code>&lt;!p</code> macro to read from promises
inside <code>go</code> blocks as if they were channels. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.async.js-promises</span>
  (<span class="symbol">:require</span> [com.wsscode.common.async-cljs <span class="symbol">:refer</span> [go-catch &lt;!p]]
            [goog.object <span class="symbol">:as</span> gobj]
            [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [com.wsscode.pathom.profile <span class="symbol">:as</span> pp]))

(<span class="keyword">def</span> <span class="function">reader</span>
  {<span class="symbol">:dog.ceo/random-dog-url</span>
   (<span class="keyword">fn</span> [_]
     (go-catch
       (<span class="keyword">-&gt;</span> (js/fetch <span class="string"><span class="delimiter">&quot;</span><span class="content">https://dog.ceo/api/breeds/image/random</span><span class="delimiter">&quot;</span></span>) &lt;!p
           (<span class="keyword">.</span>json) &lt;!p
           (gobj/get <span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>))))})

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/async-parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> reader})
                                p/error-handler-plugin
                                pp/profile-plugin]}))</code></pre>
</div>
</div>
<div x-app="interactive-parser" data-parser="async.js-promises" class="loader">
[:dog.ceo/random-dog-url]
</div>
<div class="space"></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="GraphQL"><a class="anchor" href="#GraphQL"></a><a class="link" href="#GraphQL">6. GraphQL Integration</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Pathom provides a collection of utilities to integrate with GraphQL.  There are two main ways in which
to use GraphQL:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Simple: Use utilities to convert queries/mutations to GraphQL, and parse the responses. This
gives you a quick and easy interface to existing GraphQL APIs, but is not extensible.</p>
</li>
<li>
<p>Advanced: Integrate with Connect.  This method pulls the GraphQL schema into Connect indexes with various
benefits: Tools give better support (e.g. query autocompletion within Fulcro Inspect), and you can
add your own client-side resolvers that can derive new shapes/data for the API, making it possible
to shape the external API to your local UI whims.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In both cases Pathom includes implementations of Fulcro Remotes, so you can easily drop GraphQL
support into a Fulcro application as a remote!</p>
</div>
<div class="paragraph">
<p>This chapter assumes you&#8217;re familiar with Pathom&#8217;s <a href="#AsyncParsing">async support</a>.</p>
</div>
<div class="paragraph">
<p>The namespaces concerned are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">    [com.wsscode.pathom.graphql <span class="symbol">:as</span> pg]
    [com.wsscode.pathom.connect.graphql <span class="symbol">:as</span> pcg]
    [com.wsscode.pathom.fulcro.network <span class="symbol">:as</span> pfn]</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_simple_graphql"><a class="anchor" href="#_simple_graphql"></a><a class="link" href="#_simple_graphql">6.1. Simple GraphQL</a></h3>
<div class="paragraph">
<p>There is a Fulcro Remote in <code>pfn/graphql-network</code> that allows you to easily add plain GraphQL
support to a Fulcro client like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(fulcro/new-fulcro-client
    <span class="symbol">:networking</span>
    {<span class="symbol">:remote</span>
     (pfn/graphql-network
       {<span class="symbol">::pfn/url</span> (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">https://api.github.com/graphql?access_token=</span><span class="delimiter">&quot;</span></span> token)})})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The queries from components have the following rules:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>You can use any namespace on the query keywords.</p>
</li>
<li>
<p>The <code>name</code> portion of a keyword can be hyphenated instead of camel-case</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Hyphenated names will automatically be converted to the standard GraphQL camel case.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Mutations on a Simple GraphQL remote have the following rules:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Mutations can have any namespace.  The GraphQL conversion will elide the namespace.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_simple_graphql_example"><a class="anchor" href="#_simple_graphql_example"></a><a class="link" href="#_simple_graphql_example">6.1.1. Simple GraphQL Example</a></h4>
<div class="paragraph">
<p>To demonstrate how easy it is to get a simple application going against an external GraphQL API we&#8217;ll build a simple
TODO app.  We&#8217;ve already gone to <code>graph.cool</code>, and created a GraphQL schema at <a href="https://www.graph.cool/" class="bare">https://www.graph.cool/</a> (a back-end
as a service provider).  You can play with the API by entering queries and mutations via their interface
to our endpoint at <a href="https://api.graph.cool/simple/v1/cjjkw3slu0ui40186ml4jocgk" class="bare">https://api.graph.cool/simple/v1/cjjkw3slu0ui40186ml4jocgk</a>.</p>
</div>
<div class="paragraph">
<p>For example, entering this query into the left pane:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">query {
  allTodoItems {id, title, completed}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>should give you something like this (people play with this, so yours will be different):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{
  <span class="string"><span class="delimiter">&quot;</span><span class="content">data</span><span class="delimiter">&quot;</span></span><span class="error">:</span> {
    <span class="string"><span class="delimiter">&quot;</span><span class="content">allTodoItems</span><span class="delimiter">&quot;</span></span><span class="error">:</span> [
      {
        <span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span><span class="error">:</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">cjjkw7yws06el0135q5sf372s</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span><span class="error">:</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Write docs on workspaces</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">completed</span><span class="delimiter">&quot;</span></span><span class="error">:</span> <span class="predefined-constant">true</span>
      }]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>So, you can see we have a root query that we can run to get all todo items, and each one has an id and title. So, we
can write a simple Fulcro tree of components for that query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(defsc TodoItem
  [this props]
  {<span class="symbol">:ident</span>         [<span class="symbol">:todo/id</span> <span class="symbol">:todo/id</span>]
   <span class="symbol">:query</span>         [<span class="symbol">:todo/id</span> <span class="symbol">:todo/title</span> <span class="symbol">:todo/completed</span>]}
  <span class="keyword">..</span><span class="keyword">.</span>)

(defsc TodoSimpleDemo [this props]
  {<span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">::root</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">singleton</span><span class="delimiter">&quot;</span></span>])
   <span class="symbol">:query</span>         [{<span class="symbol">:all-todo-items</span> (fp/get-query TodoItem)}]}
  <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that on <code>TodoItem</code> we namespaced the keys.  This is fine, as the integration code will strip these from the
query.  If <code>TodoSimpleDemo</code> were your root component, the query for it is <strong>already</strong> compatible with our defined API
when using our GraphQL network:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(fulcro/new-fulcro-client
  <span class="symbol">:started-callback</span>
  (<span class="keyword">fn</span> [app]
    (df/load app <span class="symbol">:all-todo-items</span> todo/TodoItem {<span class="symbol">:target</span> [<span class="symbol">::root</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">singleton</span><span class="delimiter">&quot;</span></span> <span class="symbol">:all-todo-items</span>]}))

  <span class="symbol">:networking</span>
  {<span class="symbol">:remote</span> (pfn/graphql-network <span class="string"><span class="delimiter">&quot;</span><span class="content">https://api.graph.cool/simple/v1/cjjkw3slu0ui40186ml4jocgk</span><span class="delimiter">&quot;</span></span>)})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mutations are similarly easy. The network component translates them as discussed earlier, so doing something like
adding a new todo item likes like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(fm/defmutation create-todo-item [todo]
  (action [env] <span class="keyword">..</span><span class="keyword">.</span>local optimistic stuff.<span class="keyword">..</span>)
  (remote [{<span class="symbol">:keys</span> [ast]}]
    <span class="comment">;; Don't send the UI-specific params to the server...just the id and title</span>
    (update ast <span class="symbol">:params</span> <span class="keyword">select-keys</span> [<span class="symbol">:todo/id</span> <span class="symbol">:todo/title</span>])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The full source is shown below, but hopefully you can see how simple it is to get something
going pretty quickly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">Unresolved directive in index.adoc <span class="keyword">-</span> include<span class="symbol">::..</span>/src-docs/com/wsscode/pathom/book/graphql/fulcro_network/graphql_todo.cljs[]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_graphql_and_connect"><a class="anchor" href="#_graphql_and_connect"></a><a class="link" href="#_graphql_and_connect">6.2. GraphQL and Connect</a></h3>
<div class="paragraph">
<p>The more powerful way to use GraphQL from Pathom is to use it with Connect.  This gives you the basic features
you saw in the simple version, but also gives you a lot more power and extensibility.</p>
</div>
<div class="paragraph">
<p>The integration has a bit of boilerplate, but it&#8217;s all relatively simple.  Please make sure you already
understand <a href="#Connect">Connect</a> before reading this.</p>
</div>
<div class="sect3">
<h4 id="_keywords_and_graphql_prefixes"><a class="anchor" href="#_keywords_and_graphql_prefixes"></a><a class="link" href="#_keywords_and_graphql_prefixes">6.2.1. Keywords and GraphQL – Prefixes</a></h4>
<div class="paragraph">
<p>In order to properly generate indexes Connect needs to know how you will prefix them for a given GraphQL endpoint.
From there, the keyword also gives an indication of the "type" and attribute name.</p>
</div>
<div class="paragraph">
<p>Say we are interfacting with GitHub: we might choose the prefix <code>github</code>.  Then our keywords would need to be
things like <code>:github.user/name</code>.  The name portion of the keyword can be hyphenated, and Pathom will turn that
into a camel-case name, since that is the standard for GraphQL.  Name munging is customizable via Pathom settings.</p>
</div>
<div class="paragraph">
<p>You will have to formally declare the prefix you&#8217;ve decided on in order to Connect to work.</p>
</div>
</div>
<div class="sect3">
<h4 id="_graphql_entry_points_and_connect_ident_maps"><a class="anchor" href="#_graphql_entry_points_and_connect_ident_maps"></a><a class="link" href="#_graphql_entry_points_and_connect_ident_maps">6.2.2. GraphQL Entry Points and Connect Ident Maps</a></h4>
<div class="paragraph">
<p>In GraphQL the schema designer indicates what entry points are possible.  In GitHub&#8217;s public API you can, for example,
access a <code>User</code> if you know their <code>login</code>.  You can access a <code>Repository</code> if you know <strong>both</strong> the <code>owner</code>
and the repository <code>name</code>.</p>
</div>
<div class="paragraph">
<p>You might wish to take a moment, log into GitHub, and play with these at <a href="https://developer.github.com/v4/explorer" class="bare">https://developer.github.com/v4/explorer</a>.</p>
</div>
<div class="paragraph">
<p>To look at a user, you need something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">query {
   user(login<span class="error">:</span><span class="string"><span class="delimiter">&quot;</span><span class="content">wilkerlucio</span><span class="delimiter">&quot;</span></span>) {
    createdAt
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To look at a repository, you need something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">query {
  repository(owner<span class="error">:</span><span class="string"><span class="delimiter">&quot;</span><span class="content">wilkerlucio</span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span><span class="error">:</span><span class="string"><span class="delimiter">&quot;</span><span class="content">pathom</span><span class="delimiter">&quot;</span></span>) {
    createdAt
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our EDN queries use idents to stand for these kind of entry points.  So, we&#8217;d like to be able to translate an EDN query
like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{[<span class="symbol">:github.user/login</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">wilkerlucio</span><span class="delimiter">&quot;</span></span>] [<span class="symbol">:github.user/created-at</span>]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>into the GraphQL query above.  This is the purpose of the "Ident Map".  It is a map whose top-level keys are GraphQL
entry point names, and whose value is a map of the attributes required at that entry point associated with
EDN keywords:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{ENTRY-POINT-NAME {ATTR connect-keyword
                   <span class="keyword">..</span><span class="keyword">.</span>}
 <span class="keyword">..</span><span class="keyword">.</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>So, an ident map for the above two GraphQL entry points is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>       {<span class="string"><span class="delimiter">&quot;</span><span class="content">login</span><span class="delimiter">&quot;</span></span> <span class="symbol">:github.user/login</span>}
 <span class="string"><span class="delimiter">&quot;</span><span class="content">repository</span><span class="delimiter">&quot;</span></span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">owner</span><span class="delimiter">&quot;</span></span> <span class="symbol">:github.user/login</span>
               <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>  <span class="symbol">:github.repository/name</span>}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Installing such an ident map (covered shortly) will enable this feature.</p>
</div>
<div class="paragraph">
<p>If an entry point requires more than one input (as repository does), then there is no standard EDN ident that can
directly use it.  We&#8217;ll cover how to handle that in <a href="#MultiInputIdents">Multiple Input Entry Points</a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Interestingly, this feature of Pathom gives you an ability on GraphQL that GraphQL itself doesn&#8217;t have: the ability
to nest an entry point anywhere in the query.  GraphQL only understands entry points at the root of the query, but our EDN
notation allows you to use an ident on a join at any level. Pathom Connect will correctly interpret such a join,
process it against the GraphQL system, and properly nest the result.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_setting_up_connect_with_graphql"><a class="anchor" href="#_setting_up_connect_with_graphql"></a><a class="link" href="#_setting_up_connect_with_graphql">6.2.3. Setting Up Connect with GraphQL</a></h4>
<div class="paragraph">
<p>Now that you understand entry points we can explain the rest of the setup.  A lot of it is just the standard Connect
stuff, but of course there are additions for GraphQL.</p>
</div>
<div class="paragraph">
<p>First, you need to declare a place to store the indexes, that&#8217;s because the GraphQL schema will be
loaded asynchronosly later and we need the index reference to add the GraphQL connection.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defonce</span> <span class="function">indexes</span> (<span class="keyword">atom</span> {}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>We need to define the configuration for the GraphQL connection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">github-gql</span>
  {<span class="symbol">::pcg/url</span>       (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">https://api.github.com/graphql?access_token=</span><span class="delimiter">&quot;</span></span> (ls/get <span class="symbol">:github-token</span>))
   <span class="symbol">::pcg/prefix</span>    <span class="string"><span class="delimiter">&quot;</span><span class="content">github</span><span class="delimiter">&quot;</span></span>
   <span class="symbol">::pcg/ident-map</span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>       {<span class="string"><span class="delimiter">&quot;</span><span class="content">login</span><span class="delimiter">&quot;</span></span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">User</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">login</span><span class="delimiter">&quot;</span></span>]}
                    <span class="string"><span class="delimiter">&quot;</span><span class="content">repository</span><span class="delimiter">&quot;</span></span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">owner</span><span class="delimiter">&quot;</span></span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">User</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">login</span><span class="delimiter">&quot;</span></span>]
                                  <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>  [<span class="string"><span class="delimiter">&quot;</span><span class="content">Repository</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>]}}
   <span class="symbol">::p.http/driver</span> p.http.fetch/request-async})</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>::pcg/url</code></dt>
<dd>
<p>The GraphQL API endpoint</p>
</dd>
<dt class="hdlist1"><code>::pcg/prefix</code></dt>
<dd>
<p>The prefix you&#8217;ll use in your EDN queries and mutations.</p>
</dd>
<dt class="hdlist1"><code>::pcg/ident-map</code></dt>
<dd>
<p>The definition of GraphQL entry points, as discussed previously.</p>
</dd>
<dt class="hdlist1"><code>::p.http/driver</code></dt>
<dd>
<p>A driver that can run HTTP requests.  Used to issue requests (e.g. fetch schema).</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
We&#8217;re using <code>ls/get</code> to pull our github access token from browser local storage so we don&#8217;t have to check it into
code, and so anyone can use the example unedited. In Chrome, you can set this via
the developer tools "Application" tab (once at the page for your app).  Click on local storage, then add a key value
pair.  The key should be the keyword (typed out), and the value must be a QUOTED token (e.g. "987398ahbckjhbas"). The quotes
are required!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Next, we need to create a parser. This will essentially be basically this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parallel-parser
    {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span>               [p/map-reader
                                            pc/parallel-reader
                                            pc/open-ident-reader
                                            p/env-placeholder-reader]
                  <span class="symbol">::p/placeholder-prefixes</span> #{<span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;</span><span class="delimiter">&quot;</span></span>}
                  <span class="symbol">::p.http/driver</span>          p.http.fetch/request-async}
     <span class="symbol">::p/mutate</span>  pc/mutate-async
     <span class="symbol">::p/plugins</span> [(pc/connect-plugin {<span class="comment">; we can specify the index for the connect plugin to use</span>
                                      <span class="comment">; instead of creating a new one internally</span>
                                      <span class="symbol">::pc/indexes</span>  indexes})
                  p/error-handler-plugin
                  p/request-cache-plugin
                  p/trace-plugin]}))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_loading_the_graphql_schema_and_creating_a_remote"><a class="anchor" href="#_loading_the_graphql_schema_and_creating_a_remote"></a><a class="link" href="#_loading_the_graphql_schema_and_creating_a_remote">6.2.4. Loading the GraphQL Schema and Creating a Remote</a></h4>
<div class="paragraph">
<p>The final setup step is to make sure that you load the GraphQL schema into the Connect indexes. If you&#8217;re using Fulcro
it looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(new-fulcro-client
  <span class="symbol">:started-callback</span>
  (<span class="keyword">fn</span> [app]
    (go-catch
      (<span class="keyword">try</span>
        (<span class="keyword">let</span> [idx (&lt;? (pcg/load-index github-gql))]
          (<span class="keyword">swap!</span> indexes pc/merge-indexes idx))
        (<span class="keyword">catch</span> <span class="symbol">:default</span> e (js/console.error <span class="string"><span class="delimiter">&quot;</span><span class="content">Error making index</span><span class="delimiter">&quot;</span></span> e)))))

  <span class="symbol">:networking</span>
  {<span class="symbol">:remote</span> (<span class="keyword">-&gt;</span> (create-parser)
               (pfn/pathom-remote)
               <span class="comment">;; OPTIONAL: Automatically adds profile queries to all outgoing queries, so you see profiling from the parser</span>
               (pfn/profile-remote))}}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_adding_resolvers"><a class="anchor" href="#_adding_resolvers"></a><a class="link" href="#_adding_resolvers">6.2.5. Adding Resolvers</a></h4>
<div class="paragraph">
<p>Of course we&#8217;ve done all of this setup so we can make use of (and extend the capabilities of) some GraphQL API.</p>
</div>
<div class="paragraph">
<p>The normal stuff is trivial: Make EDN queries that ask for the proper attributes in the proper context.</p>
</div>
<div class="paragraph">
<p>In our example, we might want to list some information about some repositories.  If you remember, repositories
take two pieces of information, and idents can supply only one.</p>
</div>
<div class="paragraph">
<p>That&#8217;s ok, we can define a resolver for a root-level Connect property that can pre-establish some repositories
into our context!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(pc/defresolver repositories [_ _]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">:demo-repos</span> [<span class="symbol">:github.user/login</span> <span class="symbol">:github.repository/name</span>]}]}
  {<span class="symbol">:demo-repos</span>
   [{<span class="symbol">:github.user/login</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">wilkerlucio</span><span class="delimiter">&quot;</span></span> <span class="symbol">:github.repository/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">pathom</span><span class="delimiter">&quot;</span></span>}
    {<span class="symbol">:github.user/login</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcrologic</span><span class="delimiter">&quot;</span></span> <span class="symbol">:github.repository/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcro</span><span class="delimiter">&quot;</span></span>}
    {<span class="symbol">:github.user/login</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcrologic</span><span class="delimiter">&quot;</span></span> <span class="symbol">:github.repository/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcro-inspect</span><span class="delimiter">&quot;</span></span>}
    {<span class="symbol">:github.user/login</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcrologic</span><span class="delimiter">&quot;</span></span> <span class="symbol">:github.repository/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcro-css</span><span class="delimiter">&quot;</span></span>}
    {<span class="symbol">:github.user/login</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcrologic</span><span class="delimiter">&quot;</span></span> <span class="symbol">:github.repository/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcro-spec</span><span class="delimiter">&quot;</span></span>}
    {<span class="symbol">:github.user/login</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">thheller</span><span class="delimiter">&quot;</span></span> <span class="symbol">:github.repository/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">shadow-cljs</span><span class="delimiter">&quot;</span></span>}]})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember, once Connect has enough info in a context, it can fill in the remaining details. Our Ident Map indicates
that if we have "user login" and "repository name", then we can get a repository.  Thus, a resolver that outputs
values for the keywords associated with those requirements is sufficient!</p>
</div>
<div class="paragraph">
<p>Remember to add this mutation definition before the parser, then we have to add this resolver
to our connect system, do that by updating the call to the <code>connect-plugin</code>, here is the updated
parser:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parallel-parser
    {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span>               [p/map-reader
                                            pc/parallel-reader
                                            pc/open-ident-reader
                                            p/env-placeholder-reader]
                  <span class="symbol">::p/placeholder-prefixes</span> #{<span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;</span><span class="delimiter">&quot;</span></span>}
                  <span class="symbol">::p.http/driver</span>          p.http.fetch/request-async}
     <span class="symbol">::p/mutate</span>  pc/mutate-async
     <span class="symbol">::p/plugins</span> [(pc/connect-plugin {<span class="symbol">::pc/register</span> repositories <span class="comment">; registering the resolver</span>
                                      <span class="symbol">::pc/indexes</span>  indexes})
                  p/error-handler-plugin
                  p/request-cache-plugin
                  p/trace-plugin]}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can run a query on <code>:demo-repos</code> like <code>[{:demo-repos [:github.repository/created-at]}]</code>, and walk the graph
from there to anywhere allowed!</p>
</div>
</div>
<div class="sect3">
<h4 id="_queries"><a class="anchor" href="#_queries"></a><a class="link" href="#_queries">6.2.6. Queries</a></h4>
<div class="paragraph">
<p>The queries that are supported "out of the box" are those queries that follow the allowed shape of the documented
GraphQL schema for your API.  The EDN queries in Fulcro might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(fp/defsc Repository
  [this {<span class="symbol">:github.repository/keys</span> [id name-with-owner viewer-has-starred]}]
  {<span class="symbol">:ident</span>         [<span class="symbol">:github.repository/id</span> <span class="symbol">:github.repository/id</span>]
   <span class="symbol">:query</span>         [<span class="symbol">:github.repository/id</span> <span class="symbol">:github.repository/name-with-owner</span> <span class="symbol">:github.repository/viewer-has-starred</span>]}
  <span class="keyword">..</span><span class="keyword">.</span>)

(fp/defsc GraphqlDemo
  [this {<span class="symbol">:keys</span> [demo-repos]}]
  {<span class="symbol">:query</span>         [{<span class="symbol">:demo-repos</span> (fp/get-query Repository)}]}
  (dom/div
    (mapv repository demo-repos)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>All of Connect&#8217;s additinal features (placeholder nodes, augmenting the graph, reshaping) are now also easily
accessible.</p>
</div>
</div>
<div class="sect3">
<h4 id="_fulcro_mutations_and_remote"><a class="anchor" href="#_fulcro_mutations_and_remote"></a><a class="link" href="#_fulcro_mutations_and_remote">6.2.7. Fulcro Mutations and Remote</a></h4>
<div class="paragraph">
<p>If you&#8217;re using Fulcro, then the normal method of defining mutations will work if you use the remote shown earlier. You
simply prefix the mutation name with your GraphQL <code>prefix</code> and it&#8217;ll work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(fm/defmutation github/add-star [_]
  (action [{<span class="symbol">:keys</span> [state <span class="keyword">ref</span>]}] <span class="keyword">..</span><span class="keyword">.</span>)
  (remote [_] <span class="predefined-constant">true</span>))</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
This is <strong>not</strong> the <code>defmutation</code> we showed earlier in the setup.  This is Fulcro&#8217;s <code>defmutation</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can, of course, modify the parameters, do mutation joins, etc.</p>
</div>
</div>
<div class="sect3">
<h4 id="ConnectMutations"><a class="anchor" href="#ConnectMutations"></a><a class="link" href="#ConnectMutations">6.2.8. Connect-Based Mutations</a></h4>
<div class="paragraph">
<p>It is possible that you might want to define a mutation that is <strong>not</strong> on the GraphQL API, but which does some
alternative remote operation.</p>
</div>
<div class="paragraph">
<p>The notation is the same as for resolvers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(pc/defmutation custom-mutation [_ params]
  {<span class="symbol">::pc/sym</span> 'custom-mutation         <span class="comment">;; (optional) if provided will be used as mutation symbol, otherwise it will use the def symbol (including namespace)</span>
   <span class="symbol">::pc/params</span> [<span class="symbol">:id</span> {<span class="symbol">:boo</span> [<span class="symbol">:y</span>]}]     <span class="comment">;; future autocomplete...noop now</span>
   <span class="symbol">::pc/output</span> [<span class="symbol">:x</span>]}                 <span class="comment">;; future autocomplete...</span>
  <span class="comment">;; can be async or sync.</span>
  (async/go <span class="keyword">..</span><span class="keyword">.</span>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note: The params and output are currently meant as documentation. In an upcoming version they&#8217;ll also be leveraged
for tool autocomplete.</p>
</div>
<div class="paragraph">
<p>The body of the mutation can return a value (sync) or a channel (async).  This means that the custom mutation
could do something like hit an alternate REST API.  This allows you to put in mutations that the async parser understands
and allows to be integrated into a single expression (and API), even though they are not part of the GraphQL API you&#8217;re
interacting with.</p>
</div>
<div class="paragraph">
<p>Of course, if you&#8217;re using Fulcro, then you&#8217;ll also have to make sure they&#8217;re OK with the mutation symbolically
(e.g. define a <code>fm/defmutation</code> as well).</p>
</div>
</div>
<div class="sect3">
<h4 id="MultiInputIdents"><a class="anchor" href="#MultiInputIdents"></a><a class="link" href="#MultiInputIdents">6.2.9. Multiple Input Entry Points</a></h4>
<div class="paragraph">
<p>Earlier we talked about how the Ident Map might specify GraphQL endpoints the required more than one
parameter, and the fact that EDN idents only really have a spot for one bit of data beyond
the keyword: <code>[keyword value]</code>.</p>
</div>
<div class="paragraph">
<p>Sometimes we have cases like GitHub&#8217;s repository entry point where more than one parameter is required.</p>
</div>
<div class="paragraph">
<p>This can be gracefully handled with EDN query parameters if you modify how Connect processes the query.</p>
</div>
<div class="paragraph">
<p>Since version <code>2.2.0</code> the connect readers <code>ident-reader</code> and <code>open-ident-reader</code> support the
provision of extra context information using the query parameter <code>:pathom/context</code>.</p>
</div>
<div class="paragraph">
<p>Now, remember that this query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{[<span class="symbol">:github.repository/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">n</span><span class="delimiter">&quot;</span></span>] [<span class="keyword">..</span><span class="keyword">.</span>]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>cannot work because there is only <strong>one</strong> of the required two bits of info (we also need owner).</p>
</div>
<div class="paragraph">
<p>What we&#8217;re going to do is allow parameters to make up the difference. If you unfamiliar with them,
you just surround the element of the query in a list and add a map of params, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">'[{([<span class="symbol">:github.repository/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">n</span><span class="delimiter">&quot;</span></span>] {<span class="symbol">:x</span> v}) [<span class="keyword">..</span><span class="keyword">.</span>]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is how you can use it to query for a pathom in the Github GraphQL API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{([<span class="symbol">:github.repository/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">pathom</span><span class="delimiter">&quot;</span></span>] {<span class="symbol">:pathom/context</span> {<span class="symbol">:github.repository/owner</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">wilkerlucio</span><span class="delimiter">&quot;</span></span>}}) [<span class="keyword">..</span><span class="keyword">.</span>]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem, of course, is that this is <strong>really</strong> hard on the eyes.  A bit too much nesting soup, and
you need the quote <code>'</code> in order to prevent an attempt to run a function!
But this <strong>is</strong> what we need to allow us to add in more information.  We can clean up the notation by
defining a helper function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">repository-ident</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Returns a parameterized ident that can be used as a join key to directly query a repository.</span><span class="delimiter">&quot;</span></span>
  [owner <span class="keyword">name</span>]
  (<span class="keyword">list</span> [<span class="symbol">:github.repository/name</span> <span class="keyword">name</span>] {<span class="symbol">:pathom/context</span> {<span class="symbol">:github.user/login</span> owner}}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can write a reasonable query that contains everything we need:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{(repository-ident <span class="string"><span class="delimiter">&quot;</span><span class="content">joe</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">boo</span><span class="delimiter">&quot;</span></span>) [<span class="symbol">:github.repository/created-at</span>]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>and we&#8217;re good to go!</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_complete_graphql_connect_example"><a class="anchor" href="#_complete_graphql_connect_example"></a><a class="link" href="#_complete_graphql_connect_example">6.3. Complete GraphQL Connect Example</a></h3>
<div class="paragraph">
<p>A complete working example (for workspaces) is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.workspaces.graphql.github-demo</span>
  (<span class="symbol">:require</span>
    [com.wsscode.common.async-cljs <span class="symbol">:refer</span> [go-promise let-chan &lt;!p go-catch &lt;? &lt;?maybe]]
    [com.wsscode.pathom.book.util.local-storage <span class="symbol">:as</span> ls]
    [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]
    [com.wsscode.pathom.connect.graphql <span class="symbol">:as</span> pcg]
    [com.wsscode.pathom.core <span class="symbol">:as</span> p]
    [com.wsscode.pathom.diplomat.http <span class="symbol">:as</span> p.http]
    [com.wsscode.pathom.diplomat.http.fetch <span class="symbol">:as</span> p.http.fetch]
    [com.wsscode.pathom.fulcro.network <span class="symbol">:as</span> pfn]
    [com.wsscode.pathom.viz.query-editor <span class="symbol">:as</span> pv.query-editor]
    [com.wsscode.pathom.viz.workspaces <span class="symbol">:as</span> pv.ws]
    [fulcro.client.data-fetch <span class="symbol">:as</span> df]
    [fulcro.client.localized-dom <span class="symbol">:as</span> dom]
    [fulcro.client.mutations <span class="symbol">:as</span> fm]
    [fulcro.client.primitives <span class="symbol">:as</span> fp]
    [nubank.workspaces.card-types.fulcro <span class="symbol">:as</span> ct.fulcro]
    [nubank.workspaces.core <span class="symbol">:as</span> ws]
    [nubank.workspaces.lib.fulcro-portal <span class="symbol">:as</span> f.portal]))

(<span class="keyword">defonce</span> <span class="function">indexes</span> (<span class="keyword">atom</span> {}))

(pc/defresolver repositories [_ _]
  {<span class="symbol">::pc/output</span> [{<span class="symbol">:demo-repos</span> [<span class="symbol">:github.user/login</span> <span class="symbol">:github.repository/name</span>]}]}
  {<span class="symbol">:demo-repos</span>
   [{<span class="symbol">:github.user/login</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">wilkerlucio</span><span class="delimiter">&quot;</span></span> <span class="symbol">:github.repository/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">pathom</span><span class="delimiter">&quot;</span></span>}
    {<span class="symbol">:github.user/login</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcrologic</span><span class="delimiter">&quot;</span></span> <span class="symbol">:github.repository/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcro</span><span class="delimiter">&quot;</span></span>}
    {<span class="symbol">:github.user/login</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcrologic</span><span class="delimiter">&quot;</span></span> <span class="symbol">:github.repository/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcro-inspect</span><span class="delimiter">&quot;</span></span>}
    {<span class="symbol">:github.user/login</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcrologic</span><span class="delimiter">&quot;</span></span> <span class="symbol">:github.repository/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcro-css</span><span class="delimiter">&quot;</span></span>}
    {<span class="symbol">:github.user/login</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcrologic</span><span class="delimiter">&quot;</span></span> <span class="symbol">:github.repository/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcro-spec</span><span class="delimiter">&quot;</span></span>}
    {<span class="symbol">:github.user/login</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">thheller</span><span class="delimiter">&quot;</span></span> <span class="symbol">:github.repository/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">shadow-cljs</span><span class="delimiter">&quot;</span></span>}]})

(<span class="keyword">def</span> <span class="function">github-gql</span>
  {<span class="symbol">::pcg/url</span>       (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">https://api.github.com/graphql?access_token=</span><span class="delimiter">&quot;</span></span> (ls/get <span class="symbol">:github-token</span>))
   <span class="symbol">::pcg/prefix</span>    <span class="string"><span class="delimiter">&quot;</span><span class="content">github</span><span class="delimiter">&quot;</span></span>
   <span class="symbol">::pcg/ident-map</span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>       {<span class="string"><span class="delimiter">&quot;</span><span class="content">login</span><span class="delimiter">&quot;</span></span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">User</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">login</span><span class="delimiter">&quot;</span></span>]}
                    <span class="string"><span class="delimiter">&quot;</span><span class="content">repository</span><span class="delimiter">&quot;</span></span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">owner</span><span class="delimiter">&quot;</span></span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">User</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">login</span><span class="delimiter">&quot;</span></span>]
                                  <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>  [<span class="string"><span class="delimiter">&quot;</span><span class="content">Repository</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>]}}
   <span class="symbol">::p.http/driver</span> p.http.fetch/request-async})

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parallel-parser
    {<span class="symbol">::p/env</span>     {<span class="symbol">::p/reader</span>               [p/map-reader
                                            pc/parallel-reader
                                            pc/open-ident-reader
                                            p/env-placeholder-reader]
                  <span class="symbol">::p/placeholder-prefixes</span> #{<span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;</span><span class="delimiter">&quot;</span></span>}
                  <span class="symbol">::p.http/driver</span>          p.http.fetch/request-async}
     <span class="symbol">::p/mutate</span>  pc/mutate-async
     <span class="symbol">::p/plugins</span> [(pc/connect-plugin {<span class="symbol">::pc/register</span> repositories
                                      <span class="symbol">::pc/indexes</span>  indexes})
                  p/error-handler-plugin
                  p/request-cache-plugin
                  p/trace-plugin]}))

(<span class="keyword">defonce</span> <span class="function">github-index-status</span>
  (go-promise
    (&lt;? (pcg/load-index github-gql indexes))))

(fm/defmutation github/add-star [_]
  (action [{<span class="symbol">:keys</span> [state <span class="keyword">ref</span>]}]
    (<span class="keyword">swap!</span> state <span class="keyword">update-in</span> <span class="keyword">ref</span> <span class="keyword">assoc</span> <span class="symbol">:github.repository/viewer-has-starred</span> <span class="predefined-constant">true</span>))
  (remote [_] <span class="predefined-constant">true</span>))

(fm/defmutation github/remove-star [_]
  (action [{<span class="symbol">:keys</span> [state <span class="keyword">ref</span>]}]
    (<span class="keyword">swap!</span> state <span class="keyword">update-in</span> <span class="keyword">ref</span> <span class="keyword">assoc</span> <span class="symbol">:github.repository/viewer-has-starred</span> <span class="predefined-constant">false</span>))
  (remote [_] <span class="predefined-constant">true</span>))

(fp/defsc Repository
  [this {<span class="symbol">:github.repository/keys</span> [id name-with-owner viewer-has-starred]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_]
                    {})
   <span class="symbol">:ident</span>         [<span class="symbol">:github.repository/id</span> <span class="symbol">:github.repository/id</span>]
   <span class="symbol">:query</span>         [<span class="symbol">:github.repository/id</span> <span class="symbol">:github.repository/name-with-owner</span> <span class="symbol">:github.repository/viewer-has-starred</span>]
   <span class="symbol">:css</span>           []
   <span class="symbol">:css-include</span>   []}
  (dom/div
    (dom/div name-with-owner)
    (<span class="keyword">if</span> viewer-has-starred
      (dom/button {<span class="symbol">:onClick</span> #(fp/transact! this [`{(github/remove-star {<span class="symbol">:github/input</span> {<span class="symbol">:github/starrable-id</span> ~id}})
                                                   [<span class="symbol">:client-mutation-id</span>
                                                    {<span class="symbol">:starrable</span>
                                                     [<span class="symbol">:viewer-has-starred</span>]}]}])}
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Remove star</span><span class="delimiter">&quot;</span></span>)
      (dom/button {<span class="symbol">:onClick</span> #(fp/transact! this [`{(github/add-star {<span class="symbol">:github/input</span> {<span class="symbol">:github/starrable-id</span> ~id}})
                                                   [<span class="symbol">:client-mutation-id</span>
                                                    {<span class="symbol">:starrable</span>
                                                     [<span class="symbol">:viewer-has-starred</span>]}]}])}
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Add star</span><span class="delimiter">&quot;</span></span>))))

(<span class="keyword">def</span> <span class="function">repository</span> (fp/factory Repository {<span class="symbol">:keyfn</span> <span class="symbol">:github.repository/id</span>}))

(fp/defsc GraphqlDemo
  [this {<span class="symbol">:keys</span> [demo-repos]}]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_]
                    {})
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">::root</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">singleton</span><span class="delimiter">&quot;</span></span>])
   <span class="symbol">:query</span>         [{<span class="symbol">:demo-repos</span> (fp/get-query Repository)}]
   <span class="symbol">:css</span>           []
   <span class="symbol">:css-include</span>   []}
  (dom/div
    (mapv repository demo-repos)))

(<span class="keyword">def</span> <span class="function">graphql-demo</span> (fp/factory GraphqlDemo))

<span class="comment">; setup the fulcro card to use in workspaces</span>
(ws/defcard graphql-demo
  (ct.fulcro/fulcro-card
    {<span class="symbol">::f.portal/root</span> GraphqlDemo
     <span class="symbol">::f.portal/app</span>  {<span class="symbol">:started-callback</span>
                      (<span class="keyword">fn</span> [app]
                        (go-catch
                          (<span class="keyword">try</span>
                            (&lt;? github-index-status)
                            (df/load app [<span class="symbol">::root</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">singleton</span><span class="delimiter">&quot;</span></span>] GraphqlDemo)
                            (<span class="keyword">catch</span> <span class="symbol">:default</span> e (js/console.error <span class="string"><span class="delimiter">&quot;</span><span class="content">Error making index</span><span class="delimiter">&quot;</span></span> e)))))

                      <span class="symbol">:networking</span>
                      {<span class="symbol">:remote</span> (<span class="keyword">-&gt;</span> parser
                                   (pfn/pathom-remote)
                                   (pfn/profile-remote))}}}))

<span class="comment">; creates a parser view using pathom viz to explore the graph in workspaces</span>
(ws/defcard graphql-demo-parser
  (pv.ws/pathom-card
    {<span class="symbol">::pv.ws/parser</span> #(parser % %2)
     <span class="symbol">::pv.ws/app</span>    {<span class="symbol">:started-callback</span>
                     (<span class="keyword">fn</span> [app]
                       (go-catch
                         (<span class="keyword">try</span>
                           (&lt;? github-index-status)
                           <span class="comment">; after github schema is ready we request the editor to update</span>
                           <span class="comment">; the index so the UI make it available right away</span>
                           (pv.query-editor/load-indexes app)
                           (<span class="keyword">catch</span> <span class="symbol">:default</span> e (js/console.error <span class="string"><span class="delimiter">&quot;</span><span class="content">Error making index</span><span class="delimiter">&quot;</span></span> e)))))}}))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="edn_gql"><a class="anchor" href="#edn_gql"></a><a class="link" href="#edn_gql">6.4. EDN&#8594;GraphQL</a></h3>
<div class="paragraph">
<p>Here you can try an interactive convertor. Type your EDN graph query on the left side
and see the GraphQL equivalent been generated on the right.</p>
</div>
<div x-app="edn-graphql-converter"></div>
<link rel="stylesheet" type="text/css" href="assets/css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="assets/css/book.css" />
<script src="assets/js/book/main.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-3833116-18"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-3833116-18');
</script>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 2<br>
Last updated 2019-03-01 22:05:46 EST
</div>
</div>
</body>
</html>